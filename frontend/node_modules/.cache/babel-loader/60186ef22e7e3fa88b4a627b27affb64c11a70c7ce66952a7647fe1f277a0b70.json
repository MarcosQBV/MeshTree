{"ast":null,"code":"import { _ as _defineProperty, a as _objectSpread2 } from './index-ffa87df4.esm.js';\nimport { _ as _inherits, a as _classCallCheck, b as _callSuper, c as _assertThisInitialized, d as _createClass, t as toPropertyKey } from './inherits-45ee1abe.esm.js';\nimport { TypedEventEmitter } from '../types/dist/sigma-types.esm.js';\nimport { A as ANIMATE_DEFAULTS, e as easings, i as identity, c as createNormalizationFunction, g as getPixelRatio, v as validateGraph, a as graphExtent, m as matrixFromCamera, z as zIndexOrdering, b as getMatrixImpact, d as createElement, f as multiplyVec2 } from './normalization-6ad2dc39.esm.js';\nimport { DEFAULT_SETTINGS, resolveSettings, validateSettings } from '../settings/dist/sigma-settings.esm.js';\nimport { _ as _slicedToArray, a as _arrayLikeToArray, b as _unsupportedIterableToArray, g as getPixelColor, c as colorToIndex } from './colors-2f6d17f0.esm.js';\nimport { e as extend } from './data-31990a76.esm.js';\nimport 'events';\nimport 'graphology-utils/is-graph';\n\n/**\n * Defaults.\n */\nvar DEFAULT_ZOOMING_RATIO = 1.5;\n\n/**\n * Event types.\n */\n/**\n * Camera class\n */\nvar Camera = /*#__PURE__*/function (_TypedEventEmitter) {\n  _inherits(Camera, _TypedEventEmitter);\n  function Camera() {\n    var _this;\n    _classCallCheck(this, Camera);\n    _this = _callSuper(this, Camera);\n\n    // State\n    _defineProperty(_assertThisInitialized(_this), \"x\", 0.5);\n    _defineProperty(_assertThisInitialized(_this), \"y\", 0.5);\n    _defineProperty(_assertThisInitialized(_this), \"angle\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"ratio\", 1);\n    _defineProperty(_assertThisInitialized(_this), \"minRatio\", null);\n    _defineProperty(_assertThisInitialized(_this), \"maxRatio\", null);\n    _defineProperty(_assertThisInitialized(_this), \"enabledRotation\", true);\n    _defineProperty(_assertThisInitialized(_this), \"nextFrame\", null);\n    _defineProperty(_assertThisInitialized(_this), \"previousState\", null);\n    _defineProperty(_assertThisInitialized(_this), \"enabled\", true);\n    _this.previousState = _this.getState();\n    return _this;\n  }\n\n  /**\n   * Static method used to create a Camera object with a given state.\n   */\n  _createClass(Camera, [{\n    key: \"enable\",\n    value:\n    /**\n     * Method used to enable the camera.\n     */\n    function enable() {\n      this.enabled = true;\n      return this;\n    }\n\n    /**\n     * Method used to disable the camera.\n     */\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.enabled = false;\n      return this;\n    }\n\n    /**\n     * Method used to retrieve the camera's current state.\n     */\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return {\n        x: this.x,\n        y: this.y,\n        angle: this.angle,\n        ratio: this.ratio\n      };\n    }\n\n    /**\n     * Method used to check whether the camera has the given state.\n     */\n  }, {\n    key: \"hasState\",\n    value: function hasState(state) {\n      return this.x === state.x && this.y === state.y && this.ratio === state.ratio && this.angle === state.angle;\n    }\n\n    /**\n     * Method used to retrieve the camera's previous state.\n     */\n  }, {\n    key: \"getPreviousState\",\n    value: function getPreviousState() {\n      var state = this.previousState;\n      if (!state) return null;\n      return {\n        x: state.x,\n        y: state.y,\n        angle: state.angle,\n        ratio: state.ratio\n      };\n    }\n\n    /**\n     * Method used to check minRatio and maxRatio values.\n     */\n  }, {\n    key: \"getBoundedRatio\",\n    value: function getBoundedRatio(ratio) {\n      var r = ratio;\n      if (typeof this.minRatio === \"number\") r = Math.max(r, this.minRatio);\n      if (typeof this.maxRatio === \"number\") r = Math.min(r, this.maxRatio);\n      return r;\n    }\n\n    /**\n     * Method used to check various things to return a legit state candidate.\n     */\n  }, {\n    key: \"validateState\",\n    value: function validateState(state) {\n      var validatedState = {};\n      if (typeof state.x === \"number\") validatedState.x = state.x;\n      if (typeof state.y === \"number\") validatedState.y = state.y;\n      if (this.enabledRotation && typeof state.angle === \"number\") validatedState.angle = state.angle;\n      if (typeof state.ratio === \"number\") validatedState.ratio = this.getBoundedRatio(state.ratio);\n      return validatedState;\n    }\n\n    /**\n     * Method used to check whether the camera is currently being animated.\n     */\n  }, {\n    key: \"isAnimated\",\n    value: function isAnimated() {\n      return !!this.nextFrame;\n    }\n\n    /**\n     * Method used to set the camera's state.\n     */\n  }, {\n    key: \"setState\",\n    value: function setState(state) {\n      if (!this.enabled) return this;\n\n      // Keeping track of last state\n      this.previousState = this.getState();\n      var validState = this.validateState(state);\n      if (typeof validState.x === \"number\") this.x = validState.x;\n      if (typeof validState.y === \"number\") this.y = validState.y;\n      if (this.enabledRotation && typeof validState.angle === \"number\") this.angle = validState.angle;\n      if (typeof validState.ratio === \"number\") this.ratio = validState.ratio;\n\n      // Emitting\n      if (!this.hasState(this.previousState)) this.emit(\"updated\", this.getState());\n      return this;\n    }\n\n    /**\n     * Method used to update the camera's state using a function.\n     */\n  }, {\n    key: \"updateState\",\n    value: function updateState(updater) {\n      this.setState(updater(this.getState()));\n      return this;\n    }\n\n    /**\n     * Method used to animate the camera.\n     */\n  }, {\n    key: \"animate\",\n    value: function animate(state) {\n      var _this2 = this;\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var callback = arguments.length > 2 ? arguments[2] : undefined;\n      if (!callback) return new Promise(function (resolve) {\n        return _this2.animate(state, opts, resolve);\n      });\n      if (!this.enabled) return;\n      var options = _objectSpread2(_objectSpread2({}, ANIMATE_DEFAULTS), opts);\n      var validState = this.validateState(state);\n      var easing = typeof options.easing === \"function\" ? options.easing : easings[options.easing];\n\n      // State\n      var start = Date.now(),\n        initialState = this.getState();\n\n      // Function performing the animation\n      var fn = function fn() {\n        var t = (Date.now() - start) / options.duration;\n\n        // The animation is over:\n        if (t >= 1) {\n          _this2.nextFrame = null;\n          _this2.setState(validState);\n          if (_this2.animationCallback) {\n            _this2.animationCallback.call(null);\n            _this2.animationCallback = undefined;\n          }\n          return;\n        }\n        var coefficient = easing(t);\n        var newState = {};\n        if (typeof validState.x === \"number\") newState.x = initialState.x + (validState.x - initialState.x) * coefficient;\n        if (typeof validState.y === \"number\") newState.y = initialState.y + (validState.y - initialState.y) * coefficient;\n        if (_this2.enabledRotation && typeof validState.angle === \"number\") newState.angle = initialState.angle + (validState.angle - initialState.angle) * coefficient;\n        if (typeof validState.ratio === \"number\") newState.ratio = initialState.ratio + (validState.ratio - initialState.ratio) * coefficient;\n        _this2.setState(newState);\n        _this2.nextFrame = requestAnimationFrame(fn);\n      };\n      if (this.nextFrame) {\n        cancelAnimationFrame(this.nextFrame);\n        if (this.animationCallback) this.animationCallback.call(null);\n        this.nextFrame = requestAnimationFrame(fn);\n      } else {\n        fn();\n      }\n      this.animationCallback = callback;\n    }\n\n    /**\n     * Method used to zoom the camera.\n     */\n  }, {\n    key: \"animatedZoom\",\n    value: function animatedZoom(factorOrOptions) {\n      if (!factorOrOptions) return this.animate({\n        ratio: this.ratio / DEFAULT_ZOOMING_RATIO\n      });\n      if (typeof factorOrOptions === \"number\") return this.animate({\n        ratio: this.ratio / factorOrOptions\n      });\n      return this.animate({\n        ratio: this.ratio / (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n      }, factorOrOptions);\n    }\n\n    /**\n     * Method used to unzoom the camera.\n     */\n  }, {\n    key: \"animatedUnzoom\",\n    value: function animatedUnzoom(factorOrOptions) {\n      if (!factorOrOptions) return this.animate({\n        ratio: this.ratio * DEFAULT_ZOOMING_RATIO\n      });\n      if (typeof factorOrOptions === \"number\") return this.animate({\n        ratio: this.ratio * factorOrOptions\n      });\n      return this.animate({\n        ratio: this.ratio * (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n      }, factorOrOptions);\n    }\n\n    /**\n     * Method used to reset the camera.\n     */\n  }, {\n    key: \"animatedReset\",\n    value: function animatedReset(options) {\n      return this.animate({\n        x: 0.5,\n        y: 0.5,\n        ratio: 1,\n        angle: 0\n      }, options);\n    }\n\n    /**\n     * Returns a new Camera instance, with the same state as the current camera.\n     */\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return Camera.from(this.getState());\n    }\n  }], [{\n    key: \"from\",\n    value: function from(state) {\n      var camera = new Camera();\n      return camera.setState(state);\n    }\n  }]);\n  return Camera;\n}(TypedEventEmitter);\n\n/**\n * Captor utils functions\n * ======================\n */\n\n/**\n * Extract the local X and Y coordinates from a mouse event or touch object. If\n * a DOM element is given, it uses this element's offset to compute the position\n * (this allows using events that are not bound to the container itself and\n * still have a proper position).\n *\n * @param  {event}       e - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {number}      The local Y value of the mouse.\n */\nfunction getPosition(e, dom) {\n  var bbox = dom.getBoundingClientRect();\n  return {\n    x: e.clientX - bbox.left,\n    y: e.clientY - bbox.top\n  };\n}\n\n/**\n * Convert mouse coords to sigma coords.\n *\n * @param  {event}       e   - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getMouseCoords(e, dom) {\n  var res = _objectSpread2(_objectSpread2({}, getPosition(e, dom)), {}, {\n    sigmaDefaultPrevented: false,\n    preventSigmaDefault: function preventSigmaDefault() {\n      res.sigmaDefaultPrevented = true;\n    },\n    original: e\n  });\n  return res;\n}\n\n/**\n * Convert mouse wheel event coords to sigma coords.\n *\n * @param  {event}       e   - A wheel mouse event.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getWheelCoords(e, dom) {\n  return _objectSpread2(_objectSpread2({}, getMouseCoords(e, dom)), {}, {\n    delta: getWheelDelta(e)\n  });\n}\nvar MAX_TOUCHES = 2;\nfunction getTouchesArray(touches) {\n  var arr = [];\n  for (var i = 0, l = Math.min(touches.length, MAX_TOUCHES); i < l; i++) arr.push(touches[i]);\n  return arr;\n}\n\n/**\n * Convert touch coords to sigma coords.\n *\n * @param  {event}       e   - A touch event.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getTouchCoords(e, dom) {\n  return {\n    touches: getTouchesArray(e.touches).map(function (touch) {\n      return getPosition(touch, dom);\n    }),\n    original: e\n  };\n}\n\n/**\n * Extract the wheel delta from a mouse event or touch object.\n *\n * @param  {event}  e - A mouse event or touch object.\n * @return {number}     The wheel delta of the mouse.\n */\nfunction getWheelDelta(e) {\n  // TODO: check those ratios again to ensure a clean Chrome/Firefox compat\n  if (typeof e.deltaY !== \"undefined\") return e.deltaY * -3 / 360;\n  if (typeof e.detail !== \"undefined\") return e.detail / -9;\n  throw new Error(\"Captor: could not extract delta from event.\");\n}\n\n/**\n * Abstract class representing a captor like the user's mouse or touch controls.\n */\nvar Captor = /*#__PURE__*/function (_TypedEventEmitter) {\n  _inherits(Captor, _TypedEventEmitter);\n  function Captor(container, renderer) {\n    var _this;\n    _classCallCheck(this, Captor);\n    _this = _callSuper(this, Captor);\n    // Properties\n    _this.container = container;\n    _this.renderer = renderer;\n    return _this;\n  }\n  return _createClass(Captor);\n}(TypedEventEmitter);\nvar MOUSE_SETTINGS_KEYS = [\"doubleClickTimeout\", \"doubleClickZoomingDuration\", \"doubleClickZoomingRatio\", \"dragTimeout\", \"draggedEventsTolerance\", \"inertiaDuration\", \"inertiaRatio\", \"zoomDuration\", \"zoomingRatio\"];\nvar DEFAULT_MOUSE_SETTINGS = MOUSE_SETTINGS_KEYS.reduce(function (iter, key) {\n  return _objectSpread2(_objectSpread2({}, iter), {}, _defineProperty({}, key, DEFAULT_SETTINGS[key]));\n}, {});\n\n/**\n * Event types.\n */\n/**\n * Mouse captor class.\n *\n * @constructor\n */\nvar MouseCaptor = /*#__PURE__*/function (_Captor) {\n  _inherits(MouseCaptor, _Captor);\n  function MouseCaptor(container, renderer) {\n    var _this;\n    _classCallCheck(this, MouseCaptor);\n    _this = _callSuper(this, MouseCaptor, [container, renderer]);\n\n    // Binding methods\n    // State\n    _defineProperty(_assertThisInitialized(_this), \"enabled\", true);\n    _defineProperty(_assertThisInitialized(_this), \"draggedEvents\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"downStartTime\", null);\n    _defineProperty(_assertThisInitialized(_this), \"lastMouseX\", null);\n    _defineProperty(_assertThisInitialized(_this), \"lastMouseY\", null);\n    _defineProperty(_assertThisInitialized(_this), \"isMouseDown\", false);\n    _defineProperty(_assertThisInitialized(_this), \"isMoving\", false);\n    _defineProperty(_assertThisInitialized(_this), \"movingTimeout\", null);\n    _defineProperty(_assertThisInitialized(_this), \"startCameraState\", null);\n    _defineProperty(_assertThisInitialized(_this), \"clicks\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"doubleClickTimeout\", null);\n    _defineProperty(_assertThisInitialized(_this), \"currentWheelDirection\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"settings\", DEFAULT_MOUSE_SETTINGS);\n    _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_this));\n    _this.handleRightClick = _this.handleRightClick.bind(_assertThisInitialized(_this));\n    _this.handleDown = _this.handleDown.bind(_assertThisInitialized(_this));\n    _this.handleUp = _this.handleUp.bind(_assertThisInitialized(_this));\n    _this.handleMove = _this.handleMove.bind(_assertThisInitialized(_this));\n    _this.handleWheel = _this.handleWheel.bind(_assertThisInitialized(_this));\n    _this.handleLeave = _this.handleLeave.bind(_assertThisInitialized(_this));\n    _this.handleEnter = _this.handleEnter.bind(_assertThisInitialized(_this));\n\n    // Binding events\n    container.addEventListener(\"click\", _this.handleClick, false);\n    container.addEventListener(\"contextmenu\", _this.handleRightClick, false);\n    container.addEventListener(\"mousedown\", _this.handleDown, false);\n    container.addEventListener(\"wheel\", _this.handleWheel, false);\n    container.addEventListener(\"mouseleave\", _this.handleLeave, false);\n    container.addEventListener(\"mouseenter\", _this.handleEnter, false);\n    document.addEventListener(\"mousemove\", _this.handleMove, false);\n    document.addEventListener(\"mouseup\", _this.handleUp, false);\n    return _this;\n  }\n  _createClass(MouseCaptor, [{\n    key: \"kill\",\n    value: function kill() {\n      var container = this.container;\n      container.removeEventListener(\"click\", this.handleClick);\n      container.removeEventListener(\"contextmenu\", this.handleRightClick);\n      container.removeEventListener(\"mousedown\", this.handleDown);\n      container.removeEventListener(\"wheel\", this.handleWheel);\n      container.removeEventListener(\"mouseleave\", this.handleLeave);\n      container.removeEventListener(\"mouseenter\", this.handleEnter);\n      document.removeEventListener(\"mousemove\", this.handleMove);\n      document.removeEventListener(\"mouseup\", this.handleUp);\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(e) {\n      var _this2 = this;\n      if (!this.enabled) return;\n      this.clicks++;\n      if (this.clicks === 2) {\n        this.clicks = 0;\n        if (typeof this.doubleClickTimeout === \"number\") {\n          clearTimeout(this.doubleClickTimeout);\n          this.doubleClickTimeout = null;\n        }\n        return this.handleDoubleClick(e);\n      }\n      setTimeout(function () {\n        _this2.clicks = 0;\n        _this2.doubleClickTimeout = null;\n      }, this.settings.doubleClickTimeout);\n\n      // NOTE: this is here to prevent click events on drag\n      if (this.draggedEvents < this.settings.draggedEventsTolerance) this.emit(\"click\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleRightClick\",\n    value: function handleRightClick(e) {\n      if (!this.enabled) return;\n      this.emit(\"rightClick\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleDoubleClick\",\n    value: function handleDoubleClick(e) {\n      if (!this.enabled) return;\n      e.preventDefault();\n      e.stopPropagation();\n      var mouseCoords = getMouseCoords(e, this.container);\n      this.emit(\"doubleClick\", mouseCoords);\n      if (mouseCoords.sigmaDefaultPrevented) return;\n\n      // default behavior\n      var camera = this.renderer.getCamera();\n      var newRatio = camera.getBoundedRatio(camera.getState().ratio / this.settings.doubleClickZoomingRatio);\n      camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {\n        easing: \"quadraticInOut\",\n        duration: this.settings.doubleClickZoomingDuration\n      });\n    }\n  }, {\n    key: \"handleDown\",\n    value: function handleDown(e) {\n      if (!this.enabled) return;\n\n      // We only start dragging on left button\n      if (e.button === 0) {\n        this.startCameraState = this.renderer.getCamera().getState();\n        var _getPosition = getPosition(e, this.container),\n          x = _getPosition.x,\n          y = _getPosition.y;\n        this.lastMouseX = x;\n        this.lastMouseY = y;\n        this.draggedEvents = 0;\n        this.downStartTime = Date.now();\n        this.isMouseDown = true;\n      }\n      this.emit(\"mousedown\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleUp\",\n    value: function handleUp(e) {\n      var _this3 = this;\n      if (!this.enabled || !this.isMouseDown) return;\n      var camera = this.renderer.getCamera();\n      this.isMouseDown = false;\n      if (typeof this.movingTimeout === \"number\") {\n        clearTimeout(this.movingTimeout);\n        this.movingTimeout = null;\n      }\n      var _getPosition2 = getPosition(e, this.container),\n        x = _getPosition2.x,\n        y = _getPosition2.y;\n      var cameraState = camera.getState(),\n        previousCameraState = camera.getPreviousState() || {\n          x: 0,\n          y: 0\n        };\n      if (this.isMoving) {\n        camera.animate({\n          x: cameraState.x + this.settings.inertiaRatio * (cameraState.x - previousCameraState.x),\n          y: cameraState.y + this.settings.inertiaRatio * (cameraState.y - previousCameraState.y)\n        }, {\n          duration: this.settings.inertiaDuration,\n          easing: \"quadraticOut\"\n        });\n      } else if (this.lastMouseX !== x || this.lastMouseY !== y) {\n        camera.setState({\n          x: cameraState.x,\n          y: cameraState.y\n        });\n      }\n      this.isMoving = false;\n      setTimeout(function () {\n        var shouldRefresh = _this3.draggedEvents > 0;\n        _this3.draggedEvents = 0;\n\n        // NOTE: this refresh is here to make sure `hideEdgesOnMove` can work\n        // when someone releases camera pan drag after having stopped moving.\n        // See commit: https://github.com/jacomyal/sigma.js/commit/cfd9197f70319109db6b675dd7c82be493ca95a2\n        // See also issue: https://github.com/jacomyal/sigma.js/issues/1290\n        // It could be possible to render instead of scheduling a refresh but for\n        // now it seems good enough.\n        if (shouldRefresh) _this3.renderer.refresh();\n      }, 0);\n      this.emit(\"mouseup\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(e) {\n      var _this4 = this;\n      if (!this.enabled) return;\n      var mouseCoords = getMouseCoords(e, this.container);\n\n      // Always trigger a \"mousemovebody\" event, so that it is possible to develop\n      // a drag-and-drop effect that works even when the mouse is out of the\n      // container:\n      this.emit(\"mousemovebody\", mouseCoords);\n\n      // Only trigger the \"mousemove\" event when the mouse is actually hovering\n      // the container, to avoid weirdly hovering nodes and/or edges when the\n      // mouse is not hover the container:\n      if (e.target === this.container || e.composedPath()[0] === this.container) {\n        this.emit(\"mousemove\", mouseCoords);\n      }\n      if (mouseCoords.sigmaDefaultPrevented) return;\n\n      // Handle the case when \"isMouseDown\" all the time, to allow dragging the\n      // stage while the mouse is not hover the container:\n      if (this.isMouseDown) {\n        this.isMoving = true;\n        this.draggedEvents++;\n        if (typeof this.movingTimeout === \"number\") {\n          clearTimeout(this.movingTimeout);\n        }\n        this.movingTimeout = window.setTimeout(function () {\n          _this4.movingTimeout = null;\n          _this4.isMoving = false;\n        }, this.settings.dragTimeout);\n        var camera = this.renderer.getCamera();\n        var _getPosition3 = getPosition(e, this.container),\n          eX = _getPosition3.x,\n          eY = _getPosition3.y;\n        var lastMouse = this.renderer.viewportToFramedGraph({\n          x: this.lastMouseX,\n          y: this.lastMouseY\n        });\n        var mouse = this.renderer.viewportToFramedGraph({\n          x: eX,\n          y: eY\n        });\n        var offsetX = lastMouse.x - mouse.x,\n          offsetY = lastMouse.y - mouse.y;\n        var cameraState = camera.getState();\n        var x = cameraState.x + offsetX,\n          y = cameraState.y + offsetY;\n        camera.setState({\n          x: x,\n          y: y\n        });\n        this.lastMouseX = eX;\n        this.lastMouseY = eY;\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    }\n  }, {\n    key: \"handleLeave\",\n    value: function handleLeave(e) {\n      this.emit(\"mouseleave\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleEnter\",\n    value: function handleEnter(e) {\n      this.emit(\"mouseenter\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleWheel\",\n    value: function handleWheel(e) {\n      var _this5 = this;\n      if (!this.enabled) return;\n      e.preventDefault();\n      e.stopPropagation();\n      var delta = getWheelDelta(e);\n      if (!delta) return;\n      var wheelCoords = getWheelCoords(e, this.container);\n      this.emit(\"wheel\", wheelCoords);\n      if (wheelCoords.sigmaDefaultPrevented) return;\n\n      // Default behavior\n      var ratioDiff = delta > 0 ? 1 / this.settings.zoomingRatio : this.settings.zoomingRatio;\n      var camera = this.renderer.getCamera();\n      var newRatio = camera.getBoundedRatio(camera.getState().ratio * ratioDiff);\n      var wheelDirection = delta > 0 ? 1 : -1;\n      var now = Date.now();\n\n      // Cancel events that are too close too each other and in the same direction:\n      if (this.currentWheelDirection === wheelDirection && this.lastWheelTriggerTime && now - this.lastWheelTriggerTime < this.settings.zoomDuration / 5) {\n        return;\n      }\n      camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {\n        easing: \"quadraticOut\",\n        duration: this.settings.zoomDuration\n      }, function () {\n        _this5.currentWheelDirection = 0;\n      });\n      this.currentWheelDirection = wheelDirection;\n      this.lastWheelTriggerTime = now;\n    }\n  }, {\n    key: \"setSettings\",\n    value: function setSettings(settings) {\n      this.settings = settings;\n    }\n  }]);\n  return MouseCaptor;\n}(Captor);\nvar TOUCH_SETTINGS_KEYS = [\"dragTimeout\", \"inertiaDuration\", \"inertiaRatio\"];\nvar DEFAULT_TOUCH_SETTINGS = TOUCH_SETTINGS_KEYS.reduce(function (iter, key) {\n  return _objectSpread2(_objectSpread2({}, iter), {}, _defineProperty({}, key, DEFAULT_SETTINGS[key]));\n}, {});\n\n/**\n * Event types.\n */\n/**\n * Touch captor class.\n *\n * @constructor\n */\nvar TouchCaptor = /*#__PURE__*/function (_Captor) {\n  _inherits(TouchCaptor, _Captor);\n  function TouchCaptor(container, renderer) {\n    var _this;\n    _classCallCheck(this, TouchCaptor);\n    _this = _callSuper(this, TouchCaptor, [container, renderer]);\n\n    // Binding methods:\n    _defineProperty(_assertThisInitialized(_this), \"enabled\", true);\n    _defineProperty(_assertThisInitialized(_this), \"isMoving\", false);\n    _defineProperty(_assertThisInitialized(_this), \"hasMoved\", false);\n    _defineProperty(_assertThisInitialized(_this), \"touchMode\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"startTouchesPositions\", []);\n    _defineProperty(_assertThisInitialized(_this), \"settings\", DEFAULT_TOUCH_SETTINGS);\n    _this.handleStart = _this.handleStart.bind(_assertThisInitialized(_this));\n    _this.handleLeave = _this.handleLeave.bind(_assertThisInitialized(_this));\n    _this.handleMove = _this.handleMove.bind(_assertThisInitialized(_this));\n\n    // Binding events\n    container.addEventListener(\"touchstart\", _this.handleStart, false);\n    container.addEventListener(\"touchend\", _this.handleLeave, false);\n    container.addEventListener(\"touchcancel\", _this.handleLeave, false);\n    container.addEventListener(\"touchmove\", _this.handleMove, false);\n    return _this;\n  }\n  _createClass(TouchCaptor, [{\n    key: \"kill\",\n    value: function kill() {\n      var container = this.container;\n      container.removeEventListener(\"touchstart\", this.handleStart);\n      container.removeEventListener(\"touchend\", this.handleLeave);\n      container.removeEventListener(\"touchcancel\", this.handleLeave);\n      container.removeEventListener(\"touchmove\", this.handleMove);\n    }\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return {\n        width: this.container.offsetWidth,\n        height: this.container.offsetHeight\n      };\n    }\n  }, {\n    key: \"dispatchRelatedMouseEvent\",\n    value: function dispatchRelatedMouseEvent(type, e, touch, emitter) {\n      var mousePosition = touch || e.touches[0];\n      var mouseEvent = new MouseEvent(type, {\n        clientX: mousePosition.clientX,\n        clientY: mousePosition.clientY,\n        altKey: e.altKey,\n        ctrlKey: e.ctrlKey\n      });\n      mouseEvent.isFakeSigmaMouseEvent = true;\n      (emitter || this.container).dispatchEvent(mouseEvent);\n    }\n  }, {\n    key: \"handleStart\",\n    value: function handleStart(e) {\n      var _this2 = this;\n      if (!this.enabled) return;\n\n      // Prevent default to avoid default browser behaviors...\n      e.preventDefault();\n      // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n      if (e.touches.length === 1) this.dispatchRelatedMouseEvent(\"mousedown\", e);\n      var touches = getTouchesArray(e.touches);\n      this.touchMode = touches.length;\n      this.startCameraState = this.renderer.getCamera().getState();\n      this.startTouchesPositions = touches.map(function (touch) {\n        return getPosition(touch, _this2.container);\n      });\n      this.lastTouches = touches;\n      this.lastTouchesPositions = this.startTouchesPositions;\n\n      // When there are two touches down, let's record distance and angle as well:\n      if (this.touchMode === 2) {\n        var _this$startTouchesPos = _slicedToArray(this.startTouchesPositions, 2),\n          _this$startTouchesPos2 = _this$startTouchesPos[0],\n          x0 = _this$startTouchesPos2.x,\n          y0 = _this$startTouchesPos2.y,\n          _this$startTouchesPos3 = _this$startTouchesPos[1],\n          x1 = _this$startTouchesPos3.x,\n          y1 = _this$startTouchesPos3.y;\n        this.startTouchesAngle = Math.atan2(y1 - y0, x1 - x0);\n        this.startTouchesDistance = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n      }\n      this.emit(\"touchdown\", getTouchCoords(e, this.container));\n    }\n  }, {\n    key: \"handleLeave\",\n    value: function handleLeave(e) {\n      if (!this.enabled) return;\n\n      // Prevent default to avoid default browser behaviors...\n      e.preventDefault();\n      // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n      if (e.touches.length === 0 && this.lastTouches && this.lastTouches.length) {\n        this.dispatchRelatedMouseEvent(\"mouseup\", e, this.lastTouches[0], document);\n        // ... and only click if no move was made\n        if (!this.hasMoved) {\n          this.dispatchRelatedMouseEvent(\"click\", e, this.lastTouches[0]);\n        }\n      }\n      if (this.movingTimeout) {\n        this.isMoving = false;\n        clearTimeout(this.movingTimeout);\n      }\n      switch (this.touchMode) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        case 2:\n          if (e.touches.length === 1) {\n            this.handleStart(e);\n            e.preventDefault();\n            break;\n          }\n        /* falls through */\n        case 1:\n          // TODO\n          // Dispatch event\n\n          if (this.isMoving) {\n            var camera = this.renderer.getCamera();\n            var cameraState = camera.getState(),\n              previousCameraState = camera.getPreviousState() || {\n                x: 0,\n                y: 0\n              };\n            camera.animate({\n              x: cameraState.x + this.settings.inertiaRatio * (cameraState.x - previousCameraState.x),\n              y: cameraState.y + this.settings.inertiaRatio * (cameraState.y - previousCameraState.y)\n            }, {\n              duration: this.settings.inertiaDuration,\n              easing: \"quadraticOut\"\n            });\n          }\n          this.hasMoved = false;\n          this.isMoving = false;\n          this.touchMode = 0;\n          break;\n      }\n      this.emit(\"touchup\", getTouchCoords(e, this.container));\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(e) {\n      var _this3 = this;\n      if (!this.enabled) return;\n\n      // Prevent default to avoid default browser behaviors...\n      e.preventDefault();\n      // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n      if (e.touches.length === 1) this.dispatchRelatedMouseEvent(\"mousemove\", e);\n      var touches = getTouchesArray(e.touches);\n      var touchesPositions = touches.map(function (touch) {\n        return getPosition(touch, _this3.container);\n      });\n      this.lastTouches = touches;\n      this.lastTouchesPositions = touchesPositions;\n\n      // If a move was initiated at some point and we get back to startpoint,\n      // we should still consider that we did move (which also happens after a\n      // multiple touch when only one touch remains in which case handleStart\n      // is recalled within handleLeave).\n      // Now, some mobile browsers report zero-distance moves so we also check that\n      // one of the touches did actually move from the origin position.\n      this.hasMoved || (this.hasMoved = touchesPositions.some(function (position, idx) {\n        var startPosition = _this3.startTouchesPositions[idx];\n        return position.x !== startPosition.x || position.y !== startPosition.y;\n      }));\n\n      // If there was no move, do not trigger touch moves behavior\n      if (!this.hasMoved) {\n        return;\n      }\n      this.isMoving = true;\n      if (this.movingTimeout) clearTimeout(this.movingTimeout);\n      this.movingTimeout = window.setTimeout(function () {\n        _this3.isMoving = false;\n      }, this.settings.dragTimeout);\n      var camera = this.renderer.getCamera();\n      var startCameraState = this.startCameraState;\n      switch (this.touchMode) {\n        case 1:\n          {\n            var _this$renderer$viewpo = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0]),\n              xStart = _this$renderer$viewpo.x,\n              yStart = _this$renderer$viewpo.y;\n            var _this$renderer$viewpo2 = this.renderer.viewportToFramedGraph(touchesPositions[0]),\n              x = _this$renderer$viewpo2.x,\n              y = _this$renderer$viewpo2.y;\n            camera.setState({\n              x: startCameraState.x + xStart - x,\n              y: startCameraState.y + yStart - y\n            });\n            break;\n          }\n        case 2:\n          {\n            /**\n             * Here is the thinking here:\n             *\n             * 1. We can find the new angle and ratio, by comparing the vector from \"touch one\" to \"touch two\" at the start\n             *    of the d'n'd and now\n             *\n             * 2. We can use `Camera#viewportToGraph` inside formula to retrieve the new camera position, using the graph\n             *    position of a touch at the beginning of the d'n'd (using `startCamera.viewportToGraph`) and the viewport\n             *    position of this same touch now\n             */\n            var newCameraState = {};\n            var _touchesPositions$ = touchesPositions[0],\n              x0 = _touchesPositions$.x,\n              y0 = _touchesPositions$.y;\n            var _touchesPositions$2 = touchesPositions[1],\n              x1 = _touchesPositions$2.x,\n              y1 = _touchesPositions$2.y;\n            var angleDiff = Math.atan2(y1 - y0, x1 - x0) - this.startTouchesAngle;\n            var ratioDiff = Math.hypot(y1 - y0, x1 - x0) / this.startTouchesDistance;\n\n            // 1.\n            var newRatio = camera.getBoundedRatio(startCameraState.ratio / ratioDiff);\n            newCameraState.ratio = newRatio;\n            newCameraState.angle = startCameraState.angle + angleDiff;\n\n            // 2.\n            var dimensions = this.getDimensions();\n            var touchGraphPosition = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0], {\n              cameraState: startCameraState\n            });\n            var smallestDimension = Math.min(dimensions.width, dimensions.height);\n            var dx = smallestDimension / dimensions.width;\n            var dy = smallestDimension / dimensions.height;\n            var ratio = newRatio / smallestDimension;\n\n            // Align with center of the graph:\n            var _x = x0 - smallestDimension / 2 / dx;\n            var _y = y0 - smallestDimension / 2 / dy;\n\n            // Rotate:\n            var _ref = [_x * Math.cos(-newCameraState.angle) - _y * Math.sin(-newCameraState.angle), _y * Math.cos(-newCameraState.angle) + _x * Math.sin(-newCameraState.angle)];\n            _x = _ref[0];\n            _y = _ref[1];\n            newCameraState.x = touchGraphPosition.x - _x * ratio;\n            newCameraState.y = touchGraphPosition.y + _y * ratio;\n            camera.setState(newCameraState);\n            break;\n          }\n      }\n      this.emit(\"touchmove\", getTouchCoords(e, this.container));\n    }\n  }, {\n    key: \"setSettings\",\n    value: function setSettings(settings) {\n      this.settings = settings;\n    }\n  }]);\n  return TouchCaptor;\n}(Captor);\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\n/**\n * Sigma.js Labels Heuristics\n * ===========================\n *\n * Miscellaneous heuristics related to label display.\n * @module\n */\n/**\n * Class representing a single candidate for the label grid selection.\n *\n * It also describes a deterministic way to compare two candidates to assess\n * which one is better.\n */\nvar LabelCandidate = /*#__PURE__*/function () {\n  function LabelCandidate(key, size) {\n    _classCallCheck(this, LabelCandidate);\n    this.key = key;\n    this.size = size;\n  }\n  _createClass(LabelCandidate, null, [{\n    key: \"compare\",\n    value: function compare(first, second) {\n      // First we compare by size\n      if (first.size > second.size) return -1;\n      if (first.size < second.size) return 1;\n\n      // Then since no two nodes can have the same key, we use it to\n      // deterministically tie-break by key\n      if (first.key > second.key) return 1;\n\n      // NOTE: this comparator cannot return 0\n      return -1;\n    }\n  }]);\n  return LabelCandidate;\n}();\n/**\n * Class representing a 2D spatial grid divided into constant-size cells.\n */\nvar LabelGrid = /*#__PURE__*/function () {\n  function LabelGrid() {\n    _classCallCheck(this, LabelGrid);\n    _defineProperty(this, \"width\", 0);\n    _defineProperty(this, \"height\", 0);\n    _defineProperty(this, \"cellSize\", 0);\n    _defineProperty(this, \"columns\", 0);\n    _defineProperty(this, \"rows\", 0);\n    _defineProperty(this, \"cells\", {});\n  }\n  _createClass(LabelGrid, [{\n    key: \"resizeAndClear\",\n    value: function resizeAndClear(dimensions, cellSize) {\n      this.width = dimensions.width;\n      this.height = dimensions.height;\n      this.cellSize = cellSize;\n      this.columns = Math.ceil(dimensions.width / cellSize);\n      this.rows = Math.ceil(dimensions.height / cellSize);\n      this.cells = {};\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex(pos) {\n      var xIndex = Math.floor(pos.x / this.cellSize);\n      var yIndex = Math.floor(pos.y / this.cellSize);\n      return yIndex * this.columns + xIndex;\n    }\n  }, {\n    key: \"add\",\n    value: function add(key, size, pos) {\n      var candidate = new LabelCandidate(key, size);\n      var index = this.getIndex(pos);\n      var cell = this.cells[index];\n      if (!cell) {\n        cell = [];\n        this.cells[index] = cell;\n      }\n      cell.push(candidate);\n    }\n  }, {\n    key: \"organize\",\n    value: function organize() {\n      for (var k in this.cells) {\n        var cell = this.cells[k];\n        cell.sort(LabelCandidate.compare);\n      }\n    }\n  }, {\n    key: \"getLabelsToDisplay\",\n    value: function getLabelsToDisplay(ratio, density) {\n      // TODO: work on visible nodes to optimize? ^ -> threshold outside so that memoization works?\n      // TODO: adjust threshold lower, but increase cells a bit?\n      // TODO: hunt for geom issue in disguise\n      // TODO: memoize while ratio does not move. method to force recompute\n      var cellArea = this.cellSize * this.cellSize;\n      var scaledCellArea = cellArea / ratio / ratio;\n      var scaledDensity = scaledCellArea * density / cellArea;\n      var labelsToDisplayPerCell = Math.ceil(scaledDensity);\n      var labels = [];\n      for (var k in this.cells) {\n        var cell = this.cells[k];\n        for (var i = 0; i < Math.min(labelsToDisplayPerCell, cell.length); i++) {\n          labels.push(cell[i].key);\n        }\n      }\n      return labels;\n    }\n  }]);\n  return LabelGrid;\n}();\n\n/**\n * Label heuristic selecting edge labels to display, based on displayed node\n * labels\n *\n * @param  {object} params                 - Parameters:\n * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.\n * @param  {Set}      highlightedNodes     - Highlighted nodes.\n * @param  {Graph}    graph                - The rendered graph.\n * @param  {string}   hoveredNode          - Hovered node (optional)\n * @return {Array}                         - The selected labels.\n */\nfunction edgeLabelsToDisplayFromNodes(params) {\n  var graph = params.graph,\n    hoveredNode = params.hoveredNode,\n    highlightedNodes = params.highlightedNodes,\n    displayedNodeLabels = params.displayedNodeLabels;\n  var worthyEdges = [];\n\n  // TODO: the code below can be optimized using #.forEach and batching the code per adj\n\n  // We should display an edge's label if:\n  //   - Any of its extremities is highlighted or hovered\n  //   - Both of its extremities has its label shown\n  graph.forEachEdge(function (edge, _, source, target) {\n    if (source === hoveredNode || target === hoveredNode || highlightedNodes.has(source) || highlightedNodes.has(target) || displayedNodeLabels.has(source) && displayedNodeLabels.has(target)) {\n      worthyEdges.push(edge);\n    }\n  });\n  return worthyEdges;\n}\n\n/**\n * Constants.\n */\nvar X_LABEL_MARGIN = 150;\nvar Y_LABEL_MARGIN = 50;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Important functions.\n */\nfunction applyNodeDefaults(settings, key, data) {\n  if (!hasOwnProperty.call(data, \"x\") || !hasOwnProperty.call(data, \"y\")) throw new Error(\"Sigma: could not find a valid position (x, y) for node \\\"\".concat(key, \"\\\". All your nodes must have a number \\\"x\\\" and \\\"y\\\". Maybe your forgot to apply a layout or your \\\"nodeReducer\\\" is not returning the correct data?\"));\n  if (!data.color) data.color = settings.defaultNodeColor;\n  if (!data.label && data.label !== \"\") data.label = null;\n  if (data.label !== undefined && data.label !== null) data.label = \"\" + data.label;else data.label = null;\n  if (!data.size) data.size = 2;\n  if (!hasOwnProperty.call(data, \"hidden\")) data.hidden = false;\n  if (!hasOwnProperty.call(data, \"highlighted\")) data.highlighted = false;\n  if (!hasOwnProperty.call(data, \"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultNodeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\nfunction applyEdgeDefaults(settings, _key, data) {\n  if (!data.color) data.color = settings.defaultEdgeColor;\n  if (!data.label) data.label = \"\";\n  if (!data.size) data.size = 0.5;\n  if (!hasOwnProperty.call(data, \"hidden\")) data.hidden = false;\n  if (!hasOwnProperty.call(data, \"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultEdgeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\n\n/**\n * Main class.\n *\n * @constructor\n * @param {Graph}       graph     - Graph to render.\n * @param {HTMLElement} container - DOM container in which to render.\n * @param {object}      settings  - Optional settings.\n */\nvar Sigma$1 = /*#__PURE__*/function (_TypedEventEmitter) {\n  _inherits(Sigma, _TypedEventEmitter);\n  function Sigma(graph, container) {\n    var _this;\n    var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    _classCallCheck(this, Sigma);\n    _this = _callSuper(this, Sigma);\n\n    // Resolving settings\n    _defineProperty(_assertThisInitialized(_this), \"elements\", {});\n    _defineProperty(_assertThisInitialized(_this), \"canvasContexts\", {});\n    _defineProperty(_assertThisInitialized(_this), \"webGLContexts\", {});\n    _defineProperty(_assertThisInitialized(_this), \"pickingLayers\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"textures\", {});\n    _defineProperty(_assertThisInitialized(_this), \"frameBuffers\", {});\n    _defineProperty(_assertThisInitialized(_this), \"activeListeners\", {});\n    _defineProperty(_assertThisInitialized(_this), \"labelGrid\", new LabelGrid());\n    _defineProperty(_assertThisInitialized(_this), \"nodeDataCache\", {});\n    _defineProperty(_assertThisInitialized(_this), \"edgeDataCache\", {});\n    // Indices to keep track of the index of the item inside programs\n    _defineProperty(_assertThisInitialized(_this), \"nodeProgramIndex\", {});\n    _defineProperty(_assertThisInitialized(_this), \"edgeProgramIndex\", {});\n    _defineProperty(_assertThisInitialized(_this), \"nodesWithForcedLabels\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"edgesWithForcedLabels\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"nodeExtent\", {\n      x: [0, 1],\n      y: [0, 1]\n    });\n    _defineProperty(_assertThisInitialized(_this), \"nodeZExtent\", [Infinity, -Infinity]);\n    _defineProperty(_assertThisInitialized(_this), \"edgeZExtent\", [Infinity, -Infinity]);\n    _defineProperty(_assertThisInitialized(_this), \"matrix\", identity());\n    _defineProperty(_assertThisInitialized(_this), \"invMatrix\", identity());\n    _defineProperty(_assertThisInitialized(_this), \"correctionRatio\", 1);\n    _defineProperty(_assertThisInitialized(_this), \"customBBox\", null);\n    _defineProperty(_assertThisInitialized(_this), \"normalizationFunction\", createNormalizationFunction({\n      x: [0, 1],\n      y: [0, 1]\n    }));\n    // Cache:\n    _defineProperty(_assertThisInitialized(_this), \"graphToViewportRatio\", 1);\n    _defineProperty(_assertThisInitialized(_this), \"itemIDsIndex\", {});\n    _defineProperty(_assertThisInitialized(_this), \"nodeIndices\", {});\n    _defineProperty(_assertThisInitialized(_this), \"edgeIndices\", {});\n    // Starting dimensions and pixel ratio\n    _defineProperty(_assertThisInitialized(_this), \"width\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"height\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"pixelRatio\", getPixelRatio());\n    _defineProperty(_assertThisInitialized(_this), \"pickingDownSizingRatio\", 2 * _this.pixelRatio);\n    // Graph State\n    _defineProperty(_assertThisInitialized(_this), \"displayedNodeLabels\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"displayedEdgeLabels\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"highlightedNodes\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"hoveredNode\", null);\n    _defineProperty(_assertThisInitialized(_this), \"hoveredEdge\", null);\n    // Internal states\n    _defineProperty(_assertThisInitialized(_this), \"renderFrame\", null);\n    _defineProperty(_assertThisInitialized(_this), \"renderHighlightedNodesFrame\", null);\n    _defineProperty(_assertThisInitialized(_this), \"needToProcess\", false);\n    _defineProperty(_assertThisInitialized(_this), \"checkEdgesEventsFrame\", null);\n    // Programs\n    _defineProperty(_assertThisInitialized(_this), \"nodePrograms\", {});\n    _defineProperty(_assertThisInitialized(_this), \"nodeHoverPrograms\", {});\n    _defineProperty(_assertThisInitialized(_this), \"edgePrograms\", {});\n    _this.settings = resolveSettings(settings);\n\n    // Validating\n    validateSettings(_this.settings);\n    validateGraph(graph);\n    if (!(container instanceof HTMLElement)) throw new Error(\"Sigma: container should be an html element.\");\n\n    // Properties\n    _this.graph = graph;\n    _this.container = container;\n\n    // Initializing contexts\n    _this.createWebGLContext(\"edges\", {\n      picking: settings.enableEdgeEvents\n    });\n    _this.createCanvasContext(\"edgeLabels\");\n    _this.createWebGLContext(\"nodes\", {\n      picking: true\n    });\n    _this.createCanvasContext(\"labels\");\n    _this.createCanvasContext(\"hovers\");\n    _this.createWebGLContext(\"hoverNodes\");\n    _this.createCanvasContext(\"mouse\");\n\n    // Initial resize\n    _this.resize();\n\n    // Loading programs\n    for (var type in _this.settings.nodeProgramClasses) {\n      _this.registerNodeProgram(type, _this.settings.nodeProgramClasses[type], _this.settings.nodeHoverProgramClasses[type]);\n    }\n    for (var _type in _this.settings.edgeProgramClasses) {\n      _this.registerEdgeProgram(_type, _this.settings.edgeProgramClasses[_type]);\n    }\n\n    // Initializing the camera\n    _this.camera = new Camera();\n\n    // Binding camera events\n    _this.bindCameraHandlers();\n\n    // Initializing captors\n    _this.mouseCaptor = new MouseCaptor(_this.elements.mouse, _assertThisInitialized(_this));\n    _this.mouseCaptor.setSettings(_this.settings);\n    _this.touchCaptor = new TouchCaptor(_this.elements.mouse, _assertThisInitialized(_this));\n    _this.touchCaptor.setSettings(_this.settings);\n\n    // Binding event handlers\n    _this.bindEventHandlers();\n\n    // Binding graph handlers\n    _this.bindGraphHandlers();\n\n    // Trigger eventual settings-related things\n    _this.handleSettingsUpdate();\n\n    // Processing data for the first time & render\n    _this.refresh();\n    return _this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Internal methods.\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Internal function used to register a node program\n   *\n   * @param  {string}           key              - The program's key, matching the related nodes \"type\" values.\n   * @param  {NodeProgramType}  NodeProgramClass - A nodes program class.\n   * @param  {NodeProgramType?} NodeHoverProgram - A nodes program class to render hovered nodes (optional).\n   * @return {Sigma}\n   */\n  _createClass(Sigma, [{\n    key: \"registerNodeProgram\",\n    value: function registerNodeProgram(key, NodeProgramClass, NodeHoverProgram) {\n      if (this.nodePrograms[key]) this.nodePrograms[key].kill();\n      if (this.nodeHoverPrograms[key]) this.nodeHoverPrograms[key].kill();\n      this.nodePrograms[key] = new NodeProgramClass(this.webGLContexts.nodes, this.frameBuffers.nodes, this);\n      this.nodeHoverPrograms[key] = new (NodeHoverProgram || NodeProgramClass)(this.webGLContexts.hoverNodes, null, this);\n      return this;\n    }\n\n    /**\n     * Internal function used to register an edge program\n     *\n     * @param  {string}          key              - The program's key, matching the related edges \"type\" values.\n     * @param  {EdgeProgramType} EdgeProgramClass - An edges program class.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"registerEdgeProgram\",\n    value: function registerEdgeProgram(key, EdgeProgramClass) {\n      if (this.edgePrograms[key]) this.edgePrograms[key].kill();\n      this.edgePrograms[key] = new EdgeProgramClass(this.webGLContexts.edges, this.frameBuffers.edges, this);\n      return this;\n    }\n\n    /**\n     * Internal function used to unregister a node program\n     *\n     * @param  {string} key - The program's key, matching the related nodes \"type\" values.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"unregisterNodeProgram\",\n    value: function unregisterNodeProgram(key) {\n      if (this.nodePrograms[key]) {\n        var _this$nodePrograms = this.nodePrograms,\n          program = _this$nodePrograms[key],\n          programs = _objectWithoutProperties(_this$nodePrograms, [key].map(toPropertyKey));\n        program.kill();\n        this.nodePrograms = programs;\n      }\n      if (this.nodeHoverPrograms[key]) {\n        var _this$nodeHoverProgra = this.nodeHoverPrograms,\n          _program = _this$nodeHoverProgra[key],\n          _programs = _objectWithoutProperties(_this$nodeHoverProgra, [key].map(toPropertyKey));\n        _program.kill();\n        this.nodePrograms = _programs;\n      }\n      return this;\n    }\n\n    /**\n     * Internal function used to unregister an edge program\n     *\n     * @param  {string} key - The program's key, matching the related edges \"type\" values.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"unregisterEdgeProgram\",\n    value: function unregisterEdgeProgram(key) {\n      if (this.edgePrograms[key]) {\n        var _this$edgePrograms = this.edgePrograms,\n          program = _this$edgePrograms[key],\n          programs = _objectWithoutProperties(_this$edgePrograms, [key].map(toPropertyKey));\n        program.kill();\n        this.edgePrograms = programs;\n      }\n      return this;\n    }\n\n    /**\n     * Method (re)binding WebGL texture (for picking).\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"resetWebGLTexture\",\n    value: function resetWebGLTexture(id) {\n      var gl = this.webGLContexts[id];\n      var frameBuffer = this.frameBuffers[id];\n      var currentTexture = this.textures[id];\n      if (currentTexture) gl.deleteTexture(currentTexture);\n      var pickingTexture = gl.createTexture();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n      gl.bindTexture(gl.TEXTURE_2D, pickingTexture);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, pickingTexture, 0);\n      this.textures[id] = pickingTexture;\n      return this;\n    }\n\n    /**\n     * Method binding camera handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindCameraHandlers\",\n    value: function bindCameraHandlers() {\n      var _this2 = this;\n      this.activeListeners.camera = function () {\n        _this2.scheduleRender();\n      };\n      this.camera.on(\"updated\", this.activeListeners.camera);\n      return this;\n    }\n\n    /**\n     * Method unbinding camera handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"unbindCameraHandlers\",\n    value: function unbindCameraHandlers() {\n      this.camera.removeListener(\"updated\", this.activeListeners.camera);\n      return this;\n    }\n\n    /**\n     * Method that returns the closest node to a given position.\n     */\n  }, {\n    key: \"getNodeAtPosition\",\n    value: function getNodeAtPosition(position) {\n      var x = position.x,\n        y = position.y;\n      var color = getPixelColor(this.webGLContexts.nodes, this.frameBuffers.nodes, x, y, this.pixelRatio, this.pickingDownSizingRatio);\n      var index = colorToIndex.apply(void 0, _toConsumableArray(color));\n      var itemAt = this.itemIDsIndex[index];\n      return itemAt && itemAt.type === \"node\" ? itemAt.id : null;\n    }\n\n    /**\n     * Method binding event handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindEventHandlers\",\n    value: function bindEventHandlers() {\n      var _this3 = this;\n      // Handling window resize\n      this.activeListeners.handleResize = function () {\n        // need to call a refresh to rebuild the labelgrid\n        _this3.scheduleRefresh();\n      };\n      window.addEventListener(\"resize\", this.activeListeners.handleResize);\n\n      // Handling mouse move\n      this.activeListeners.handleMove = function (e) {\n        var baseEvent = {\n          event: e,\n          preventSigmaDefault: function preventSigmaDefault() {\n            e.preventSigmaDefault();\n          }\n        };\n        var nodeToHover = _this3.getNodeAtPosition(e);\n        if (nodeToHover && _this3.hoveredNode !== nodeToHover && !_this3.nodeDataCache[nodeToHover].hidden) {\n          // Handling passing from one node to the other directly\n          if (_this3.hoveredNode) _this3.emit(\"leaveNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: _this3.hoveredNode\n          }));\n          _this3.hoveredNode = nodeToHover;\n          _this3.emit(\"enterNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: nodeToHover\n          }));\n          _this3.scheduleHighlightedNodesRender();\n          return;\n        }\n\n        // Checking if the hovered node is still hovered\n        if (_this3.hoveredNode) {\n          if (_this3.getNodeAtPosition(e) !== _this3.hoveredNode) {\n            var node = _this3.hoveredNode;\n            _this3.hoveredNode = null;\n            _this3.emit(\"leaveNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              node: node\n            }));\n            _this3.scheduleHighlightedNodesRender();\n            return;\n          }\n        }\n        if (_this3.settings.enableEdgeEvents) {\n          var edgeToHover = _this3.hoveredNode ? null : _this3.getEdgeAtPoint(baseEvent.event.x, baseEvent.event.y);\n          if (edgeToHover !== _this3.hoveredEdge) {\n            if (_this3.hoveredEdge) _this3.emit(\"leaveEdge\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              edge: _this3.hoveredEdge\n            }));\n            if (edgeToHover) _this3.emit(\"enterEdge\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              edge: edgeToHover\n            }));\n            _this3.hoveredEdge = edgeToHover;\n          }\n        }\n      };\n\n      // Handling mouse leave stage:\n      this.activeListeners.handleLeave = function (e) {\n        var baseEvent = {\n          event: e,\n          preventSigmaDefault: function preventSigmaDefault() {\n            e.preventSigmaDefault();\n          }\n        };\n        if (_this3.hoveredNode) {\n          _this3.emit(\"leaveNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: _this3.hoveredNode\n          }));\n          _this3.scheduleHighlightedNodesRender();\n        }\n        if (_this3.settings.enableEdgeEvents && _this3.hoveredEdge) {\n          _this3.emit(\"leaveEdge\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            edge: _this3.hoveredEdge\n          }));\n          _this3.scheduleHighlightedNodesRender();\n        }\n        _this3.emit(\"leaveStage\", _objectSpread2({}, baseEvent));\n      };\n\n      // Handling mouse enter stage:\n      this.activeListeners.handleEnter = function (e) {\n        var baseEvent = {\n          event: e,\n          preventSigmaDefault: function preventSigmaDefault() {\n            e.preventSigmaDefault();\n          }\n        };\n        _this3.emit(\"enterStage\", _objectSpread2({}, baseEvent));\n      };\n\n      // Handling click\n      var createMouseListener = function createMouseListener(eventType) {\n        return function (e) {\n          var baseEvent = {\n            event: e,\n            preventSigmaDefault: function preventSigmaDefault() {\n              e.preventSigmaDefault();\n            }\n          };\n          var isFakeSigmaMouseEvent = e.original.isFakeSigmaMouseEvent;\n          var nodeAtPosition = isFakeSigmaMouseEvent ? _this3.getNodeAtPosition(e) : _this3.hoveredNode;\n          if (nodeAtPosition) return _this3.emit(\"\".concat(eventType, \"Node\"), _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: nodeAtPosition\n          }));\n          if (_this3.settings.enableEdgeEvents) {\n            var edge = _this3.getEdgeAtPoint(e.x, e.y);\n            if (edge) return _this3.emit(\"\".concat(eventType, \"Edge\"), _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              edge: edge\n            }));\n          }\n          return _this3.emit(\"\".concat(eventType, \"Stage\"), baseEvent);\n        };\n      };\n      this.activeListeners.handleClick = createMouseListener(\"click\");\n      this.activeListeners.handleRightClick = createMouseListener(\"rightClick\");\n      this.activeListeners.handleDoubleClick = createMouseListener(\"doubleClick\");\n      this.activeListeners.handleWheel = createMouseListener(\"wheel\");\n      this.activeListeners.handleDown = createMouseListener(\"down\");\n      this.activeListeners.handleUp = createMouseListener(\"up\");\n      this.mouseCaptor.on(\"mousemove\", this.activeListeners.handleMove);\n      this.mouseCaptor.on(\"click\", this.activeListeners.handleClick);\n      this.mouseCaptor.on(\"rightClick\", this.activeListeners.handleRightClick);\n      this.mouseCaptor.on(\"doubleClick\", this.activeListeners.handleDoubleClick);\n      this.mouseCaptor.on(\"wheel\", this.activeListeners.handleWheel);\n      this.mouseCaptor.on(\"mousedown\", this.activeListeners.handleDown);\n      this.mouseCaptor.on(\"mouseup\", this.activeListeners.handleUp);\n      this.mouseCaptor.on(\"mouseleave\", this.activeListeners.handleLeave);\n      this.mouseCaptor.on(\"mouseenter\", this.activeListeners.handleEnter);\n\n      // TODO\n      // Deal with Touch captor events\n\n      return this;\n    }\n\n    /**\n     * Method binding graph handlers\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindGraphHandlers\",\n    value: function bindGraphHandlers() {\n      var _this4 = this;\n      var graph = this.graph;\n      var LAYOUT_IMPACTING_FIELDS = new Set([\"x\", \"y\", \"zIndex\", \"type\"]);\n      this.activeListeners.eachNodeAttributesUpdatedGraphUpdate = function (e) {\n        var _e$hints;\n        var updatedFields = (_e$hints = e.hints) === null || _e$hints === void 0 ? void 0 : _e$hints.attributes;\n        // we process all nodes\n        _this4.graph.forEachNode(function (node) {\n          return _this4.updateNode(node);\n        });\n\n        // if coord, type or zIndex have changed, we need to schedule a render\n        // (zIndex for the programIndex)\n        var layoutChanged = !updatedFields || updatedFields.some(function (f) {\n          return LAYOUT_IMPACTING_FIELDS.has(f);\n        });\n        _this4.refresh({\n          partialGraph: {\n            nodes: graph.nodes()\n          },\n          skipIndexation: !layoutChanged,\n          schedule: true\n        });\n      };\n      this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate = function (e) {\n        var _e$hints2;\n        var updatedFields = (_e$hints2 = e.hints) === null || _e$hints2 === void 0 ? void 0 : _e$hints2.attributes;\n        // we process all edges\n        _this4.graph.forEachEdge(function (edge) {\n          return _this4.updateEdge(edge);\n        });\n        var layoutChanged = updatedFields && [\"zIndex\", \"type\"].some(function (f) {\n          return updatedFields === null || updatedFields === void 0 ? void 0 : updatedFields.includes(f);\n        });\n        _this4.refresh({\n          partialGraph: {\n            edges: graph.edges()\n          },\n          skipIndexation: !layoutChanged,\n          schedule: true\n        });\n      };\n\n      // On add node, we add the node in indices and then call for a render\n      this.activeListeners.addNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // we process the node\n        _this4.addNode(node);\n        // schedule a render for the node\n        _this4.refresh({\n          partialGraph: {\n            nodes: [node]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On update node, we update indices and then call for a render\n      this.activeListeners.updateNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // schedule a render for the node\n        _this4.refresh({\n          partialGraph: {\n            nodes: [node]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On drop node, we remove the node from indices and then call for a refresh\n      this.activeListeners.dropNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // we process the node\n        _this4.removeNode(node);\n        // schedule a render for everything\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On add edge, we remove the edge from indices and then call for a refresh\n      this.activeListeners.addEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // we process the edge\n        _this4.addEdge(edge);\n        // schedule a render for the edge\n        _this4.refresh({\n          partialGraph: {\n            edges: [edge]\n          },\n          schedule: true\n        });\n      };\n\n      // On update edge, we update indices and then call for a refresh\n      this.activeListeners.updateEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // schedule a repaint for the edge\n        _this4.refresh({\n          partialGraph: {\n            edges: [edge]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On drop edge, we remove the edge from indices and then call for a refresh\n      this.activeListeners.dropEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // we process the edge\n        _this4.removeEdge(edge);\n        // schedule a render for all edges\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On clear edges, we clear the edge indices and then call for a refresh\n      this.activeListeners.clearEdgesGraphUpdate = function () {\n        // we clear the edge data structures\n        _this4.clearEdgeState();\n        _this4.clearEdgeIndices();\n        // schedule a render for all edges\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On graph clear, we clear indices and then call for a refresh\n      this.activeListeners.clearGraphUpdate = function () {\n        // clear graph state\n        _this4.clearEdgeState();\n        _this4.clearNodeState();\n\n        // clear graph indices\n        _this4.clearEdgeIndices();\n        _this4.clearNodeIndices();\n\n        // schedule a render for all\n        _this4.refresh({\n          schedule: true\n        });\n      };\n      graph.on(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n      graph.on(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n      graph.on(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n      graph.on(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n      graph.on(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n      graph.on(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n      graph.on(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n      graph.on(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n      graph.on(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n      graph.on(\"cleared\", this.activeListeners.clearGraphUpdate);\n      return this;\n    }\n\n    /**\n     * Method used to unbind handlers from the graph.\n     *\n     * @return {undefined}\n     */\n  }, {\n    key: \"unbindGraphHandlers\",\n    value: function unbindGraphHandlers() {\n      var graph = this.graph;\n      graph.removeListener(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n      graph.removeListener(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n      graph.removeListener(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n      graph.removeListener(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n      graph.removeListener(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n      graph.removeListener(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n      graph.removeListener(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n      graph.removeListener(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n      graph.removeListener(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n      graph.removeListener(\"cleared\", this.activeListeners.clearGraphUpdate);\n    }\n\n    /**\n     * Method looking for an edge colliding with a given point at (x, y). Returns\n     * the key of the edge if any, or null else.\n     */\n  }, {\n    key: \"getEdgeAtPoint\",\n    value: function getEdgeAtPoint(x, y) {\n      var color = getPixelColor(this.webGLContexts.edges, this.frameBuffers.edges, x, y, this.pixelRatio, this.pickingDownSizingRatio);\n      var index = colorToIndex.apply(void 0, _toConsumableArray(color));\n      var itemAt = this.itemIDsIndex[index];\n      return itemAt && itemAt.type === \"edge\" ? itemAt.id : null;\n    }\n\n    /**\n     * Method used to process the whole graph's data.\n     *  - extent\n     *  - normalizationFunction\n     *  - compute node's coordinate\n     *  - labelgrid\n     *  - program data allocation\n     * @return {Sigma}\n     */\n  }, {\n    key: \"process\",\n    value: function process() {\n      var _this5 = this;\n      this.emit(\"beforeProcess\");\n      var graph = this.graph;\n      var settings = this.settings;\n      var dimensions = this.getDimensions();\n\n      //\n      // NODES\n      //\n      this.nodeExtent = graphExtent(this.graph);\n      if (!this.settings.autoRescale) {\n        var width = dimensions.width,\n          height = dimensions.height;\n        var _this$nodeExtent = this.nodeExtent,\n          x = _this$nodeExtent.x,\n          y = _this$nodeExtent.y;\n        this.nodeExtent = {\n          x: [(x[0] + x[1]) / 2 - width / 2, (x[0] + x[1]) / 2 + width / 2],\n          y: [(y[0] + y[1]) / 2 - height / 2, (y[0] + y[1]) / 2 + height / 2]\n        };\n      }\n      this.normalizationFunction = createNormalizationFunction(this.customBBox || this.nodeExtent);\n\n      // NOTE: it is important to compute this matrix after computing the node's extent\n      // because #.getGraphDimensions relies on it\n      var nullCamera = new Camera();\n      var nullCameraMatrix = matrixFromCamera(nullCamera.getState(), dimensions, this.getGraphDimensions(), this.getStagePadding());\n      // Resetting the label grid\n      // TODO: it's probably better to do this explicitly or on resizes for layout and anims\n      this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);\n      var nodesPerPrograms = {};\n      var nodeIndices = {};\n      var edgeIndices = {};\n      var itemIDsIndex = {};\n      var incrID = 1;\n      var nodes = graph.nodes();\n\n      // Do some indexation on the whole graph\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        var node = nodes[i];\n        var data = this.nodeDataCache[node];\n\n        // Get initial coordinates\n        var attrs = graph.getNodeAttributes(node);\n        data.x = attrs.x;\n        data.y = attrs.y;\n        this.normalizationFunction.applyTo(data);\n\n        // labelgrid\n        if (typeof data.label === \"string\" && !data.hidden) this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, {\n          matrix: nullCameraMatrix\n        }));\n\n        // update count per program\n        nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;\n      }\n      this.labelGrid.organize();\n\n      // Allocate memory to programs\n      for (var type in this.nodePrograms) {\n        if (!hasOwnProperty.call(this.nodePrograms, type)) {\n          throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(type, \"\\\"!\"));\n        }\n        this.nodePrograms[type].reallocate(nodesPerPrograms[type] || 0);\n        // We reset that count here, so that we can reuse it while calling the Program#process methods:\n        nodesPerPrograms[type] = 0;\n      }\n\n      // Order nodes by zIndex before to add them to program\n      if (this.settings.zIndex && this.nodeZExtent[0] !== this.nodeZExtent[1]) nodes = zIndexOrdering(this.nodeZExtent, function (node) {\n        return _this5.nodeDataCache[node].zIndex;\n      }, nodes);\n\n      // Add data to programs\n      for (var _i = 0, _l = nodes.length; _i < _l; _i++) {\n        var _node = nodes[_i];\n        nodeIndices[_node] = incrID;\n        itemIDsIndex[nodeIndices[_node]] = {\n          type: \"node\",\n          id: _node\n        };\n        incrID++;\n        var _data = this.nodeDataCache[_node];\n        this.addNodeToProgram(_node, nodeIndices[_node], nodesPerPrograms[_data.type]++);\n      }\n\n      //\n      // EDGES\n      //\n\n      var edgesPerPrograms = {};\n      var edges = graph.edges();\n\n      // Allocate memory to programs\n      for (var _i2 = 0, _l2 = edges.length; _i2 < _l2; _i2++) {\n        var edge = edges[_i2];\n        var _data2 = this.edgeDataCache[edge];\n        edgesPerPrograms[_data2.type] = (edgesPerPrograms[_data2.type] || 0) + 1;\n      }\n\n      // Order edges by zIndex before to add them to program\n      if (this.settings.zIndex && this.edgeZExtent[0] !== this.edgeZExtent[1]) edges = zIndexOrdering(this.edgeZExtent, function (edge) {\n        return _this5.edgeDataCache[edge].zIndex;\n      }, edges);\n      for (var _type2 in this.edgePrograms) {\n        if (!hasOwnProperty.call(this.edgePrograms, _type2)) {\n          throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(_type2, \"\\\"!\"));\n        }\n        this.edgePrograms[_type2].reallocate(edgesPerPrograms[_type2] || 0);\n        // We reset that count here, so that we can reuse it while calling the Program#process methods:\n        edgesPerPrograms[_type2] = 0;\n      }\n\n      // Add data to programs\n      for (var _i3 = 0, _l3 = edges.length; _i3 < _l3; _i3++) {\n        var _edge = edges[_i3];\n        edgeIndices[_edge] = incrID;\n        itemIDsIndex[edgeIndices[_edge]] = {\n          type: \"edge\",\n          id: _edge\n        };\n        incrID++;\n        var _data3 = this.edgeDataCache[_edge];\n        this.addEdgeToProgram(_edge, edgeIndices[_edge], edgesPerPrograms[_data3.type]++);\n      }\n      this.itemIDsIndex = itemIDsIndex;\n      this.nodeIndices = nodeIndices;\n      this.edgeIndices = edgeIndices;\n      this.emit(\"afterProcess\");\n      return this;\n    }\n\n    /**\n     * Method that backports potential settings updates where it's needed.\n     * @private\n     */\n  }, {\n    key: \"handleSettingsUpdate\",\n    value: function handleSettingsUpdate(oldSettings) {\n      var settings = this.settings;\n      this.camera.minRatio = settings.minCameraRatio;\n      this.camera.maxRatio = settings.maxCameraRatio;\n      this.camera.enabledRotation = settings.enableCameraRotation;\n      this.camera.setState(this.camera.validateState(this.camera.getState()));\n      if (oldSettings) {\n        // Check edge programs:\n        if (oldSettings.edgeProgramClasses !== settings.edgeProgramClasses) {\n          for (var type in settings.edgeProgramClasses) {\n            if (settings.edgeProgramClasses[type] !== oldSettings.edgeProgramClasses[type]) {\n              this.registerEdgeProgram(type, settings.edgeProgramClasses[type]);\n            }\n          }\n          for (var _type3 in oldSettings.edgeProgramClasses) {\n            if (!settings.edgeProgramClasses[_type3]) this.unregisterEdgeProgram(_type3);\n          }\n        }\n\n        // Check node programs:\n        if (oldSettings.nodeProgramClasses !== settings.nodeProgramClasses || oldSettings.nodeHoverProgramClasses !== settings.nodeHoverProgramClasses) {\n          for (var _type4 in settings.nodeProgramClasses) {\n            if (settings.nodeProgramClasses[_type4] !== oldSettings.nodeProgramClasses[_type4] || settings.nodeHoverProgramClasses[_type4] !== oldSettings.nodeHoverProgramClasses[_type4]) {\n              this.registerNodeProgram(_type4, settings.nodeProgramClasses[_type4], settings.nodeHoverProgramClasses[_type4]);\n            }\n          }\n          for (var _type5 in oldSettings.nodeProgramClasses) {\n            if (!settings.nodeProgramClasses[_type5]) this.unregisterNodeProgram(_type5);\n          }\n        }\n      }\n\n      // Update captors settings:\n      this.mouseCaptor.setSettings(this.settings);\n      this.touchCaptor.setSettings(this.settings);\n      return this;\n    }\n\n    /**\n     * Method used to render labels.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderLabels\",\n    value: function renderLabels() {\n      if (!this.settings.renderLabels) return this;\n      var cameraState = this.camera.getState();\n\n      // Selecting labels to draw\n      var labelsToDisplay = this.labelGrid.getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity);\n      extend(labelsToDisplay, this.nodesWithForcedLabels);\n      this.displayedNodeLabels = new Set();\n\n      // Drawing labels\n      var context = this.canvasContexts.labels;\n      for (var i = 0, l = labelsToDisplay.length; i < l; i++) {\n        var node = labelsToDisplay[i];\n        var data = this.nodeDataCache[node];\n\n        // If the node was already drawn (like if it is eligible AND has\n        // `forceLabel`), we don't want to draw it again\n        // NOTE: we can do better probably\n        if (this.displayedNodeLabels.has(node)) continue;\n\n        // If the node is hidden, we don't need to display its label obviously\n        if (data.hidden) continue;\n        var _this$framedGraphToVi = this.framedGraphToViewport(data),\n          x = _this$framedGraphToVi.x,\n          y = _this$framedGraphToVi.y;\n\n        // NOTE: we can cache the labels we need to render until the camera's ratio changes\n        var size = this.scaleSize(data.size);\n\n        // Is node big enough?\n        if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold) continue;\n\n        // Is node actually on screen (with some margin)\n        // NOTE: we used to rely on the quadtree for this, but the coordinates\n        // conversion make it unreliable and at that point we already converted\n        // to viewport coordinates and since the label grid already culls the\n        // number of potential labels to display this looks like a good\n        // performance compromise.\n        // NOTE: labelGrid.getLabelsToDisplay could probably optimize by not\n        // considering cells obviously outside of the range of the current\n        // view rectangle.\n        if (x < -X_LABEL_MARGIN || x > this.width + X_LABEL_MARGIN || y < -Y_LABEL_MARGIN || y > this.height + Y_LABEL_MARGIN) continue;\n\n        // Because displayed edge labels depend directly on actually rendered node\n        // labels, we need to only add to this.displayedNodeLabels nodes whose label\n        // is rendered.\n        // This makes this.displayedNodeLabels depend on viewport, which might become\n        // an issue once we start memoizing getLabelsToDisplay.\n        this.displayedNodeLabels.add(node);\n        var defaultDrawNodeLabel = this.settings.defaultDrawNodeLabel;\n        var nodeProgram = this.nodePrograms[data.type];\n        var drawLabel = (nodeProgram === null || nodeProgram === void 0 ? void 0 : nodeProgram.drawLabel) || defaultDrawNodeLabel;\n        drawLabel(context, _objectSpread2(_objectSpread2({\n          key: node\n        }, data), {}, {\n          size: size,\n          x: x,\n          y: y\n        }), this.settings);\n      }\n      return this;\n    }\n\n    /**\n     * Method used to render edge labels, based on which node labels were\n     * rendered.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderEdgeLabels\",\n    value: function renderEdgeLabels() {\n      if (!this.settings.renderEdgeLabels) return this;\n      var context = this.canvasContexts.edgeLabels;\n\n      // Clearing\n      context.clearRect(0, 0, this.width, this.height);\n      var edgeLabelsToDisplay = edgeLabelsToDisplayFromNodes({\n        graph: this.graph,\n        hoveredNode: this.hoveredNode,\n        displayedNodeLabels: this.displayedNodeLabels,\n        highlightedNodes: this.highlightedNodes\n      });\n      extend(edgeLabelsToDisplay, this.edgesWithForcedLabels);\n      var displayedLabels = new Set();\n      for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {\n        var edge = edgeLabelsToDisplay[i],\n          extremities = this.graph.extremities(edge),\n          sourceData = this.nodeDataCache[extremities[0]],\n          targetData = this.nodeDataCache[extremities[1]],\n          edgeData = this.edgeDataCache[edge];\n\n        // If the edge was already drawn (like if it is eligible AND has\n        // `forceLabel`), we don't want to draw it again\n        if (displayedLabels.has(edge)) continue;\n\n        // If the edge is hidden we don't need to display its label\n        // NOTE: the test on sourceData & targetData is probably paranoid at this point?\n        if (edgeData.hidden || sourceData.hidden || targetData.hidden) {\n          continue;\n        }\n        var defaultDrawEdgeLabel = this.settings.defaultDrawEdgeLabel;\n        var edgeProgram = this.edgePrograms[edgeData.type];\n        var drawLabel = (edgeProgram === null || edgeProgram === void 0 ? void 0 : edgeProgram.drawLabel) || defaultDrawEdgeLabel;\n        drawLabel(context, _objectSpread2(_objectSpread2({\n          key: edge\n        }, edgeData), {}, {\n          size: this.scaleSize(edgeData.size)\n        }), _objectSpread2(_objectSpread2(_objectSpread2({\n          key: extremities[0]\n        }, sourceData), this.framedGraphToViewport(sourceData)), {}, {\n          size: this.scaleSize(sourceData.size)\n        }), _objectSpread2(_objectSpread2(_objectSpread2({\n          key: extremities[1]\n        }, targetData), this.framedGraphToViewport(targetData)), {}, {\n          size: this.scaleSize(targetData.size)\n        }), this.settings);\n        displayedLabels.add(edge);\n      }\n      this.displayedEdgeLabels = displayedLabels;\n      return this;\n    }\n\n    /**\n     * Method used to render the highlighted nodes.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderHighlightedNodes\",\n    value: function renderHighlightedNodes() {\n      var _this6 = this;\n      var context = this.canvasContexts.hovers;\n\n      // Clearing\n      context.clearRect(0, 0, this.width, this.height);\n\n      // Rendering\n      var render = function render(node) {\n        var data = _this6.nodeDataCache[node];\n        var _this6$framedGraphToV = _this6.framedGraphToViewport(data),\n          x = _this6$framedGraphToV.x,\n          y = _this6$framedGraphToV.y;\n        var size = _this6.scaleSize(data.size);\n        var defaultDrawNodeHover = _this6.settings.defaultDrawNodeHover;\n        var nodeProgram = _this6.nodePrograms[data.type];\n        var drawHover = (nodeProgram === null || nodeProgram === void 0 ? void 0 : nodeProgram.drawHover) || defaultDrawNodeHover;\n        drawHover(context, _objectSpread2(_objectSpread2({\n          key: node\n        }, data), {}, {\n          size: size,\n          x: x,\n          y: y\n        }), _this6.settings);\n      };\n      var nodesToRender = [];\n      if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {\n        nodesToRender.push(this.hoveredNode);\n      }\n      this.highlightedNodes.forEach(function (node) {\n        // The hovered node has already been highlighted\n        if (node !== _this6.hoveredNode) nodesToRender.push(node);\n      });\n\n      // Draw labels:\n      nodesToRender.forEach(function (node) {\n        return render(node);\n      });\n\n      // Draw WebGL nodes on top of the labels:\n      var nodesPerPrograms = {};\n\n      // 1. Count nodes per type:\n      nodesToRender.forEach(function (node) {\n        var type = _this6.nodeDataCache[node].type;\n        nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;\n      });\n      // 2. Allocate for each type for the proper number of nodes\n      for (var type in this.nodeHoverPrograms) {\n        this.nodeHoverPrograms[type].reallocate(nodesPerPrograms[type] || 0);\n        // Also reset count, to use when rendering:\n        nodesPerPrograms[type] = 0;\n      }\n      // 3. Process all nodes to render:\n      nodesToRender.forEach(function (node) {\n        var data = _this6.nodeDataCache[node];\n        _this6.nodeHoverPrograms[data.type].process(0, nodesPerPrograms[data.type]++, data);\n      });\n      // 4. Clear hovered nodes layer:\n      this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n      // 5. Render:\n      var renderParams = this.getRenderParams();\n      for (var _type6 in this.nodeHoverPrograms) {\n        var program = this.nodeHoverPrograms[_type6];\n        program.render(renderParams);\n      }\n    }\n\n    /**\n     * Method used to schedule a hover render.\n     *\n     */\n  }, {\n    key: \"scheduleHighlightedNodesRender\",\n    value: function scheduleHighlightedNodesRender() {\n      var _this7 = this;\n      if (this.renderHighlightedNodesFrame || this.renderFrame) return;\n      this.renderHighlightedNodesFrame = requestAnimationFrame(function () {\n        // Resetting state\n        _this7.renderHighlightedNodesFrame = null;\n\n        // Rendering\n        _this7.renderHighlightedNodes();\n        _this7.renderEdgeLabels();\n      });\n    }\n\n    /**\n     * Method used to render.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this8 = this;\n      this.emit(\"beforeRender\");\n      var exitRender = function exitRender() {\n        _this8.emit(\"afterRender\");\n        return _this8;\n      };\n\n      // If a render was scheduled, we cancel it\n      if (this.renderFrame) {\n        cancelAnimationFrame(this.renderFrame);\n        this.renderFrame = null;\n      }\n\n      // First we need to resize\n      this.resize();\n\n      // Do we need to reprocess data?\n      if (this.needToProcess) this.process();\n      this.needToProcess = false;\n\n      // Clearing the canvases\n      this.clear();\n\n      // Prepare the textures\n      this.pickingLayers.forEach(function (layer) {\n        return _this8.resetWebGLTexture(layer);\n      });\n\n      // If we have no nodes we can stop right there\n      if (!this.graph.order) return exitRender();\n\n      // TODO: improve this heuristic or move to the captor itself?\n      // TODO: deal with the touch captor here as well\n      var mouseCaptor = this.mouseCaptor;\n      var moving = this.camera.isAnimated() || mouseCaptor.isMoving || mouseCaptor.draggedEvents || mouseCaptor.currentWheelDirection;\n\n      // Then we need to extract a matrix from the camera\n      var cameraState = this.camera.getState();\n      var viewportDimensions = this.getDimensions();\n      var graphDimensions = this.getGraphDimensions();\n      var padding = this.getStagePadding();\n      this.matrix = matrixFromCamera(cameraState, viewportDimensions, graphDimensions, padding);\n      this.invMatrix = matrixFromCamera(cameraState, viewportDimensions, graphDimensions, padding, true);\n      this.correctionRatio = getMatrixImpact(this.matrix, cameraState, viewportDimensions);\n      this.graphToViewportRatio = this.getGraphToViewportRatio();\n\n      // [jacomyal]\n      // This comment is related to the one above the `getMatrixImpact` definition:\n      // - `this.correctionRatio` is somehow not completely explained\n      // - `this.graphToViewportRatio` is the ratio of a distance in the viewport divided by the same distance in the\n      //   graph\n      // - `this.normalizationFunction.ratio` is basically `Math.max(graphDX, graphDY)`\n      // And now, I observe that if I multiply these three ratios, I have something constant, which value remains 2, even\n      // when I change the graph, the viewport or the camera. It might be useful later, so I prefer to let this comment:\n      // console.log(this.graphToViewportRatio * this.correctionRatio * this.normalizationFunction.ratio * 2);\n\n      var params = this.getRenderParams();\n\n      // Drawing nodes\n      for (var type in this.nodePrograms) {\n        var program = this.nodePrograms[type];\n        program.render(params);\n      }\n\n      // Drawing edges\n      if (!this.settings.hideEdgesOnMove || !moving) {\n        for (var _type7 in this.edgePrograms) {\n          var _program2 = this.edgePrograms[_type7];\n          _program2.render(params);\n        }\n      }\n\n      // Do not display labels on move per setting\n      if (this.settings.hideLabelsOnMove && moving) return exitRender();\n      this.renderLabels();\n      this.renderEdgeLabels();\n      this.renderHighlightedNodes();\n      return exitRender();\n    }\n\n    /**\n     * Add a node in the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"addNode\",\n    value: function addNode(key) {\n      // Node display data resolution:\n      //  1. First we get the node's attributes\n      //  2. We optionally reduce them using the function provided by the user\n      //     Note that this function must return a total object and won't be merged\n      //  3. We apply our defaults, while running some vital checks\n      //  4. We apply the normalization function\n      // We shallow copy node data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, this.graph.getNodeAttributes(key));\n      if (this.settings.nodeReducer) attr = this.settings.nodeReducer(key, attr);\n      var data = applyNodeDefaults(this.settings, key, attr);\n      this.nodeDataCache[key] = data;\n\n      // Label:\n      // We delete and add if needed because this function is also used from\n      // update\n      this.nodesWithForcedLabels[\"delete\"](key);\n      if (data.forceLabel && !data.hidden) this.nodesWithForcedLabels.add(key);\n\n      // Highlighted:\n      // We remove and re add if needed because this function is also used from\n      // update\n      this.highlightedNodes[\"delete\"](key);\n      if (data.highlighted && !data.hidden) this.highlightedNodes.add(key);\n\n      // zIndex\n      if (this.settings.zIndex) {\n        if (data.zIndex < this.nodeZExtent[0]) this.nodeZExtent[0] = data.zIndex;\n        if (data.zIndex > this.nodeZExtent[1]) this.nodeZExtent[1] = data.zIndex;\n      }\n    }\n\n    /**\n     * Update a node the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"updateNode\",\n    value: function updateNode(key) {\n      this.addNode(key);\n\n      // Re-apply normalization on the node\n      var data = this.nodeDataCache[key];\n      this.normalizationFunction.applyTo(data);\n    }\n\n    /**\n     * Remove a node from the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"removeNode\",\n    value: function removeNode(key) {\n      // Remove from node cache\n      delete this.nodeDataCache[key];\n      // Remove from node program index\n      delete this.nodeProgramIndex[key];\n      // Remove from higlighted nodes\n      this.highlightedNodes[\"delete\"](key);\n      // Remove from hovered\n      if (this.hoveredNode === key) this.hoveredNode = null;\n      // Remove from forced label\n      this.nodesWithForcedLabels[\"delete\"](key);\n    }\n\n    /**\n     * Add an edge into the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"addEdge\",\n    value: function addEdge(key) {\n      // Edge display data resolution:\n      //  1. First we get the edge's attributes\n      //  2. We optionally reduce them using the function provided by the user\n      //  3. Note that this function must return a total object and won't be merged\n      //  4. We apply our defaults, while running some vital checks\n      // We shallow copy edge data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, this.graph.getEdgeAttributes(key));\n      if (this.settings.edgeReducer) attr = this.settings.edgeReducer(key, attr);\n      var data = applyEdgeDefaults(this.settings, key, attr);\n      this.edgeDataCache[key] = data;\n\n      // Forced label\n      // we filter and re push if needed because this function is also used from\n      // update\n      this.edgesWithForcedLabels[\"delete\"](key);\n      if (data.forceLabel && !data.hidden) this.edgesWithForcedLabels.add(key);\n\n      // Check zIndex\n      if (this.settings.zIndex) {\n        if (data.zIndex < this.edgeZExtent[0]) this.edgeZExtent[0] = data.zIndex;\n        if (data.zIndex > this.edgeZExtent[1]) this.edgeZExtent[1] = data.zIndex;\n      }\n    }\n\n    /**\n     * Update an edge in the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"updateEdge\",\n    value: function updateEdge(key) {\n      this.addEdge(key);\n    }\n\n    /**\n     * Remove an edge from the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"removeEdge\",\n    value: function removeEdge(key) {\n      // Remove from edge cache\n      delete this.edgeDataCache[key];\n      // Remove from programId index\n      delete this.edgeProgramIndex[key];\n      // Remove from hovered\n      if (this.hoveredEdge === key) this.hoveredEdge = null;\n      // Remove from forced label\n      this.edgesWithForcedLabels[\"delete\"](key);\n    }\n\n    /**\n     * Clear all indices related to nodes.\n     * @private\n     */\n  }, {\n    key: \"clearNodeIndices\",\n    value: function clearNodeIndices() {\n      // LabelGrid & nodeExtent are only manage/populated in the process function\n      this.labelGrid = new LabelGrid();\n      this.nodeExtent = {\n        x: [0, 1],\n        y: [0, 1]\n      };\n      this.nodeDataCache = {};\n      this.edgeProgramIndex = {};\n      this.nodesWithForcedLabels = new Set();\n      this.nodeZExtent = [Infinity, -Infinity];\n    }\n\n    /**\n     * Clear all indices related to edges.\n     * @private\n     */\n  }, {\n    key: \"clearEdgeIndices\",\n    value: function clearEdgeIndices() {\n      this.edgeDataCache = {};\n      this.edgeProgramIndex = {};\n      this.edgesWithForcedLabels = new Set();\n      this.edgeZExtent = [Infinity, -Infinity];\n    }\n\n    /**\n     * Clear all indices.\n     * @private\n     */\n  }, {\n    key: \"clearIndices\",\n    value: function clearIndices() {\n      this.clearEdgeIndices();\n      this.clearNodeIndices();\n    }\n\n    /**\n     * Clear all graph state related to nodes.\n     * @private\n     */\n  }, {\n    key: \"clearNodeState\",\n    value: function clearNodeState() {\n      this.displayedNodeLabels = new Set();\n      this.highlightedNodes = new Set();\n      this.hoveredNode = null;\n    }\n\n    /**\n     * Clear all graph state related to edges.\n     * @private\n     */\n  }, {\n    key: \"clearEdgeState\",\n    value: function clearEdgeState() {\n      this.displayedEdgeLabels = new Set();\n      this.highlightedNodes = new Set();\n      this.hoveredEdge = null;\n    }\n\n    /**\n     * Clear all graph state.\n     * @private\n     */\n  }, {\n    key: \"clearState\",\n    value: function clearState() {\n      this.clearEdgeState();\n      this.clearNodeState();\n    }\n\n    /**\n     * Add the node data to its program.\n     * @private\n     * @param node The node's graphology ID\n     * @param fingerprint A fingerprint used to identity the node with picking\n     * @param position The index where to place the node in the program\n     */\n  }, {\n    key: \"addNodeToProgram\",\n    value: function addNodeToProgram(node, fingerprint, position) {\n      var data = this.nodeDataCache[node];\n      var nodeProgram = this.nodePrograms[data.type];\n      if (!nodeProgram) throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(data.type, \"\\\"!\"));\n      nodeProgram.process(fingerprint, position, data);\n      // Saving program index\n      this.nodeProgramIndex[node] = position;\n    }\n\n    /**\n     * Add the edge data to its program.\n     * @private\n     * @param edge The edge's graphology ID\n     * @param fingerprint A fingerprint used to identity the edge with picking\n     * @param position The index where to place the edge in the program\n     */\n  }, {\n    key: \"addEdgeToProgram\",\n    value: function addEdgeToProgram(edge, fingerprint, position) {\n      var data = this.edgeDataCache[edge];\n      var edgeProgram = this.edgePrograms[data.type];\n      if (!edgeProgram) throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(data.type, \"\\\"!\"));\n      var extremities = this.graph.extremities(edge),\n        sourceData = this.nodeDataCache[extremities[0]],\n        targetData = this.nodeDataCache[extremities[1]];\n      edgeProgram.process(fingerprint, position, sourceData, targetData, data);\n      // Saving program index\n      this.edgeProgramIndex[edge] = position;\n    }\n\n    /**---------------------------------------------------------------------------\n     * Public API.\n     **---------------------------------------------------------------------------\n     */\n\n    /**\n     * Function used to get the render params.\n     *\n     * @return {RenderParams}\n     */\n  }, {\n    key: \"getRenderParams\",\n    value: function getRenderParams() {\n      return {\n        matrix: this.matrix,\n        invMatrix: this.invMatrix,\n        width: this.width,\n        height: this.height,\n        pixelRatio: this.pixelRatio,\n        zoomRatio: this.camera.ratio,\n        cameraAngle: this.camera.angle,\n        sizeRatio: 1 / this.scaleSize(),\n        correctionRatio: this.correctionRatio,\n        downSizingRatio: this.pickingDownSizingRatio,\n        minEdgeThickness: this.settings.minEdgeThickness,\n        antiAliasingFeather: this.settings.antiAliasingFeather\n      };\n    }\n\n    /**\n     * Function used to retrieve the actual stage padding value.\n     *\n     * @return {number}\n     */\n  }, {\n    key: \"getStagePadding\",\n    value: function getStagePadding() {\n      var _this$settings = this.settings,\n        stagePadding = _this$settings.stagePadding,\n        autoRescale = _this$settings.autoRescale;\n      return autoRescale ? stagePadding || 0 : 0;\n    }\n\n    /**\n     * Function used to create a canvas element.\n     *\n     * @param {string} id - Context's id.\n     * @param options\n     * @return {Sigma}\n     */\n  }, {\n    key: \"createCanvas\",\n    value: function createCanvas(id) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (this.elements[id]) throw new Error(\"Sigma: a layer named \\\"\".concat(id, \"\\\" already exists\"));\n      var canvas = createElement(\"canvas\", {\n        position: \"absolute\"\n      }, {\n        \"class\": \"sigma-\".concat(id)\n      });\n      this.elements[id] = canvas;\n      if (\"beforeLayer\" in options && options.beforeLayer) {\n        this.elements[options.beforeLayer].before(canvas);\n      } else if (\"afterLayer\" in options && options.afterLayer) {\n        this.elements[options.afterLayer].after(canvas);\n      } else {\n        this.container.appendChild(canvas);\n      }\n      return canvas;\n    }\n\n    /**\n     * Function used to create a canvas context and add the relevant DOM elements.\n     *\n     * @param  {string} id - Context's id.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"createCanvasContext\",\n    value: function createCanvasContext(id) {\n      var canvas = this.createCanvas(id);\n      var contextOptions = {\n        preserveDrawingBuffer: false,\n        antialias: false\n      };\n      this.canvasContexts[id] = canvas.getContext(\"2d\", contextOptions);\n      return this;\n    }\n\n    /**\n     * Function used to create a WebGL context and add the relevant DOM\n     * elements.\n     *\n     * @param  {string}  id      - Context's id.\n     * @param  {object?} options - #getContext params to override (optional)\n     * @return {WebGLRenderingContext}\n     */\n  }, {\n    key: \"createWebGLContext\",\n    value: function createWebGLContext(id, options) {\n      var canvas = (options === null || options === void 0 ? void 0 : options.canvas) || this.createCanvas(id);\n      if (options !== null && options !== void 0 && options.hidden) canvas.remove();\n      var contextOptions = _objectSpread2({\n        preserveDrawingBuffer: false,\n        antialias: false\n      }, options || {});\n      var context;\n\n      // First we try webgl2 for an easy performance boost\n      context = canvas.getContext(\"webgl2\", contextOptions);\n\n      // Else we fall back to webgl\n      if (!context) context = canvas.getContext(\"webgl\", contextOptions);\n\n      // Edge, I am looking right at you...\n      if (!context) context = canvas.getContext(\"experimental-webgl\", contextOptions);\n      var gl = context;\n      this.webGLContexts[id] = gl;\n\n      // Blending:\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n      // Prepare frame buffer for picking layers:\n      if (options !== null && options !== void 0 && options.picking) {\n        this.pickingLayers.add(id);\n        var newFrameBuffer = gl.createFramebuffer();\n        if (!newFrameBuffer) throw new Error(\"Sigma: cannot create a new frame buffer for layer \".concat(id));\n        this.frameBuffers[id] = newFrameBuffer;\n      }\n      return gl;\n    }\n\n    /**\n     * Function used to properly kill a canvas layer.\n     *\n     * @param  {string} id - Layer id.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"killLayer\",\n    value: function killLayer(id) {\n      var canvas = this.elements[id];\n      if (!canvas) throw new Error(\"Sigma: cannot kill layer \".concat(id, \", which does not exist\"));\n      if (this.webGLContexts[id]) {\n        var _gl$getExtension;\n        var gl = this.webGLContexts[id];\n        (_gl$getExtension = gl.getExtension(\"WEBGL_lose_context\")) === null || _gl$getExtension === void 0 || _gl$getExtension.loseContext();\n        delete this.webGLContexts[id];\n      } else {\n        delete this.canvasContexts[id];\n      }\n\n      // Delete canvas:\n      canvas.remove();\n      delete this.elements[id];\n      return this;\n    }\n\n    /**\n     * Method returning the renderer's camera.\n     *\n     * @return {Camera}\n     */\n  }, {\n    key: \"getCamera\",\n    value: function getCamera() {\n      return this.camera;\n    }\n\n    /**\n     * Method setting the renderer's camera.\n     *\n     * @param  {Camera} camera - New camera.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setCamera\",\n    value: function setCamera(camera) {\n      this.unbindCameraHandlers();\n      this.camera = camera;\n      this.bindCameraHandlers();\n    }\n\n    /**\n     * Method returning the container DOM element.\n     *\n     * @return {HTMLElement}\n     */\n  }, {\n    key: \"getContainer\",\n    value: function getContainer() {\n      return this.container;\n    }\n\n    /**\n     * Method returning the renderer's graph.\n     *\n     * @return {Graph}\n     */\n  }, {\n    key: \"getGraph\",\n    value: function getGraph() {\n      return this.graph;\n    }\n\n    /**\n     * Method used to set the renderer's graph.\n     *\n     * @return {Graph}\n     */\n  }, {\n    key: \"setGraph\",\n    value: function setGraph(graph) {\n      if (graph === this.graph) return;\n\n      // Unbinding handlers on the current graph\n      this.unbindGraphHandlers();\n      if (this.checkEdgesEventsFrame !== null) {\n        cancelAnimationFrame(this.checkEdgesEventsFrame);\n        this.checkEdgesEventsFrame = null;\n      }\n\n      // Installing new graph\n      this.graph = graph;\n\n      // Binding new handlers\n      this.bindGraphHandlers();\n\n      // Re-rendering now to avoid discrepancies from now to next frame\n      this.refresh();\n    }\n\n    /**\n     * Method returning the mouse captor.\n     *\n     * @return {MouseCaptor}\n     */\n  }, {\n    key: \"getMouseCaptor\",\n    value: function getMouseCaptor() {\n      return this.mouseCaptor;\n    }\n\n    /**\n     * Method returning the touch captor.\n     *\n     * @return {TouchCaptor}\n     */\n  }, {\n    key: \"getTouchCaptor\",\n    value: function getTouchCaptor() {\n      return this.touchCaptor;\n    }\n\n    /**\n     * Method returning the current renderer's dimensions.\n     *\n     * @return {Dimensions}\n     */\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return {\n        width: this.width,\n        height: this.height\n      };\n    }\n\n    /**\n     * Method returning the current graph's dimensions.\n     *\n     * @return {Dimensions}\n     */\n  }, {\n    key: \"getGraphDimensions\",\n    value: function getGraphDimensions() {\n      var extent = this.customBBox || this.nodeExtent;\n      return {\n        width: extent.x[1] - extent.x[0] || 1,\n        height: extent.y[1] - extent.y[0] || 1\n      };\n    }\n\n    /**\n     * Method used to get all the sigma node attributes.\n     * It's usefull for example to get the position of a node\n     * and to get values that are set by the nodeReducer\n     *\n     * @param  {string} key - The node's key.\n     * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found\n     */\n  }, {\n    key: \"getNodeDisplayData\",\n    value: function getNodeDisplayData(key) {\n      var node = this.nodeDataCache[key];\n      return node ? Object.assign({}, node) : undefined;\n    }\n\n    /**\n     * Method used to get all the sigma edge attributes.\n     * It's useful for example to get values that are set by the edgeReducer.\n     *\n     * @param  {string} key - The edge's key.\n     * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found\n     */\n  }, {\n    key: \"getEdgeDisplayData\",\n    value: function getEdgeDisplayData(key) {\n      var edge = this.edgeDataCache[key];\n      return edge ? Object.assign({}, edge) : undefined;\n    }\n\n    /**\n     * Method used to get the set of currently displayed node labels.\n     *\n     * @return {Set<string>} A set of node keys whose label is displayed.\n     */\n  }, {\n    key: \"getNodeDisplayedLabels\",\n    value: function getNodeDisplayedLabels() {\n      return new Set(this.displayedNodeLabels);\n    }\n\n    /**\n     * Method used to get the set of currently displayed edge labels.\n     *\n     * @return {Set<string>} A set of edge keys whose label is displayed.\n     */\n  }, {\n    key: \"getEdgeDisplayedLabels\",\n    value: function getEdgeDisplayedLabels() {\n      return new Set(this.displayedEdgeLabels);\n    }\n\n    /**\n     * Method returning a copy of the settings collection.\n     *\n     * @return {Settings} A copy of the settings collection.\n     */\n  }, {\n    key: \"getSettings\",\n    value: function getSettings() {\n      return _objectSpread2({}, this.settings);\n    }\n\n    /**\n     * Method returning the current value for a given setting key.\n     *\n     * @param  {string} key - The setting key to get.\n     * @return {any} The value attached to this setting key or undefined if not found\n     */\n  }, {\n    key: \"getSetting\",\n    value: function getSetting(key) {\n      return this.settings[key];\n    }\n\n    /**\n     * Method setting the value of a given setting key. Note that this will schedule\n     * a new render next frame.\n     *\n     * @param  {string} key - The setting key to set.\n     * @param  {any}    value - The value to set.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setSetting\",\n    value: function setSetting(key, value) {\n      var oldValues = _objectSpread2({}, this.settings);\n      this.settings[key] = value;\n      validateSettings(this.settings);\n      this.handleSettingsUpdate(oldValues);\n      this.scheduleRefresh();\n      return this;\n    }\n\n    /**\n     * Method updating the value of a given setting key using the provided function.\n     * Note that this will schedule a new render next frame.\n     *\n     * @param  {string}   key     - The setting key to set.\n     * @param  {function} updater - The update function.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"updateSetting\",\n    value: function updateSetting(key, updater) {\n      this.setSetting(key, updater(this.settings[key]));\n      return this;\n    }\n\n    /**\n     * Method used to resize the renderer.\n     *\n     * @param  {boolean} force - If true, then resize is processed even if size is unchanged (optional).\n     * @return {Sigma}\n     */\n  }, {\n    key: \"resize\",\n    value: function resize(force) {\n      var previousWidth = this.width,\n        previousHeight = this.height;\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n      this.pixelRatio = getPixelRatio();\n      if (this.width === 0) {\n        if (this.settings.allowInvalidContainer) this.width = 1;else throw new Error(\"Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n      }\n      if (this.height === 0) {\n        if (this.settings.allowInvalidContainer) this.height = 1;else throw new Error(\"Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n      }\n\n      // If nothing has changed, we can stop right here\n      if (!force && previousWidth === this.width && previousHeight === this.height) return this;\n      this.emit(\"resize\");\n\n      // Sizing dom elements\n      for (var id in this.elements) {\n        var element = this.elements[id];\n        element.style.width = this.width + \"px\";\n        element.style.height = this.height + \"px\";\n      }\n\n      // Sizing canvas contexts\n      for (var _id in this.canvasContexts) {\n        this.elements[_id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n        this.elements[_id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n        if (this.pixelRatio !== 1) this.canvasContexts[_id].scale(this.pixelRatio, this.pixelRatio);\n      }\n\n      // Sizing WebGL contexts\n      for (var _id2 in this.webGLContexts) {\n        this.elements[_id2].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n        this.elements[_id2].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n        var gl = this.webGLContexts[_id2];\n        gl.viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);\n\n        // Clear picking texture if needed\n        if (this.pickingLayers.has(_id2)) {\n          var currentTexture = this.textures[_id2];\n          if (currentTexture) gl.deleteTexture(currentTexture);\n        }\n      }\n      return this;\n    }\n\n    /**\n     * Method used to clear all the canvases.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.emit(\"beforeClear\");\n      this.webGLContexts.nodes.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n      this.webGLContexts.nodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.webGLContexts.edges.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n      this.webGLContexts.edges.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.webGLContexts.hoverNodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);\n      this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);\n      this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);\n      this.emit(\"afterClear\");\n      return this;\n    }\n\n    /**\n     * Method used to refresh, i.e. force the renderer to reprocess graph\n     * data and render, but keep the state.\n     * - if a partialGraph is provided, we only reprocess those nodes & edges.\n     * - if schedule is TRUE, we schedule a render instead of sync render\n     * - if skipIndexation is TRUE, then labelGrid & program indexation are skipped (can be used if you haven't modify x, y, zIndex & size)\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh(opts) {\n      var _this9 = this;\n      var skipIndexation = (opts === null || opts === void 0 ? void 0 : opts.skipIndexation) !== undefined ? opts === null || opts === void 0 ? void 0 : opts.skipIndexation : false;\n      var schedule = (opts === null || opts === void 0 ? void 0 : opts.schedule) !== undefined ? opts.schedule : false;\n      var fullRefresh = !opts || !opts.partialGraph;\n      if (fullRefresh) {\n        // Re-index graph data\n        this.clearEdgeIndices();\n        this.clearNodeIndices();\n        this.graph.forEachNode(function (node) {\n          return _this9.addNode(node);\n        });\n        this.graph.forEachEdge(function (edge) {\n          return _this9.addEdge(edge);\n        });\n      } else {\n        var _opts$partialGraph, _opts$partialGraph2;\n        var nodes = ((_opts$partialGraph = opts.partialGraph) === null || _opts$partialGraph === void 0 ? void 0 : _opts$partialGraph.nodes) || [];\n        for (var i = 0, l = (nodes === null || nodes === void 0 ? void 0 : nodes.length) || 0; i < l; i++) {\n          var node = nodes[i];\n          // Recompute node's data (ie. apply reducer)\n          this.updateNode(node);\n          // Add node to the program if layout is unchanged.\n          // otherwise it will be done in the process function\n          if (skipIndexation) {\n            var programIndex = this.nodeProgramIndex[node];\n            if (programIndex === undefined) throw new Error(\"Sigma: node \\\"\".concat(node, \"\\\" can't be repaint\"));\n            this.addNodeToProgram(node, this.nodeIndices[node], programIndex);\n          }\n        }\n        var edges = (opts === null || opts === void 0 || (_opts$partialGraph2 = opts.partialGraph) === null || _opts$partialGraph2 === void 0 ? void 0 : _opts$partialGraph2.edges) || [];\n        for (var _i4 = 0, _l4 = edges.length; _i4 < _l4; _i4++) {\n          var edge = edges[_i4];\n          // Recompute edge's data (ie. apply reducer)\n          this.updateEdge(edge);\n          // Add edge to the program\n          // otherwise it will be done in the process function\n          if (skipIndexation) {\n            var _programIndex = this.edgeProgramIndex[edge];\n            if (_programIndex === undefined) throw new Error(\"Sigma: edge \\\"\".concat(edge, \"\\\" can't be repaint\"));\n            this.addEdgeToProgram(edge, this.edgeIndices[edge], _programIndex);\n          }\n        }\n      }\n\n      // Do we need to call the process function ?\n      if (fullRefresh || !skipIndexation) this.needToProcess = true;\n      if (schedule) this.scheduleRender();else this.render();\n      return this;\n    }\n\n    /**\n     * Method used to schedule a render at the next available frame.\n     * This method can be safely called on a same frame because it basically\n     * debounces refresh to the next frame.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"scheduleRender\",\n    value: function scheduleRender() {\n      var _this10 = this;\n      if (!this.renderFrame) {\n        this.renderFrame = requestAnimationFrame(function () {\n          _this10.render();\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Method used to schedule a refresh (i.e. fully reprocess graph data and render)\n     * at the next available frame.\n     * This method can be safely called on a same frame because it basically\n     * debounces refresh to the next frame.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"scheduleRefresh\",\n    value: function scheduleRefresh(opts) {\n      return this.refresh(_objectSpread2(_objectSpread2({}, opts), {}, {\n        schedule: true\n      }));\n    }\n\n    /**\n     * Method used to (un)zoom, while preserving the position of a viewport point.\n     * Used for instance to zoom \"on the mouse cursor\".\n     *\n     * @param viewportTarget\n     * @param newRatio\n     * @return {CameraState}\n     */\n  }, {\n    key: \"getViewportZoomedState\",\n    value: function getViewportZoomedState(viewportTarget, newRatio) {\n      var _this$camera$getState = this.camera.getState(),\n        ratio = _this$camera$getState.ratio,\n        angle = _this$camera$getState.angle,\n        x = _this$camera$getState.x,\n        y = _this$camera$getState.y;\n      var _this$settings2 = this.settings,\n        minCameraRatio = _this$settings2.minCameraRatio,\n        maxCameraRatio = _this$settings2.maxCameraRatio;\n      if (typeof maxCameraRatio === \"number\") newRatio = Math.min(newRatio, maxCameraRatio);\n      if (typeof minCameraRatio === \"number\") newRatio = Math.max(newRatio, minCameraRatio);\n      var ratioDiff = newRatio / ratio;\n      var center = {\n        x: this.width / 2,\n        y: this.height / 2\n      };\n      var graphMousePosition = this.viewportToFramedGraph(viewportTarget);\n      var graphCenterPosition = this.viewportToFramedGraph(center);\n      return {\n        angle: angle,\n        x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,\n        y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,\n        ratio: newRatio\n      };\n    }\n\n    /**\n     * Method returning the abstract rectangle containing the graph according\n     * to the camera's state.\n     *\n     * @return {object} - The view's rectangle.\n     */\n  }, {\n    key: \"viewRectangle\",\n    value: function viewRectangle() {\n      var p1 = this.viewportToFramedGraph({\n          x: 0,\n          y: 0\n        }),\n        p2 = this.viewportToFramedGraph({\n          x: this.width,\n          y: 0\n        }),\n        h = this.viewportToFramedGraph({\n          x: 0,\n          y: this.height\n        });\n      return {\n        x1: p1.x,\n        y1: p1.y,\n        x2: p2.x,\n        y2: p2.y,\n        height: p2.y - h.y\n      };\n    }\n\n    /**\n     * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n  }, {\n    key: \"framedGraphToViewport\",\n    value: function framedGraphToViewport(coordinates) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;\n      var matrix = override.matrix ? override.matrix : recomputeMatrix ? matrixFromCamera(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getStagePadding()) : this.matrix;\n      var viewportPos = multiplyVec2(matrix, coordinates);\n      return {\n        x: (1 + viewportPos.x) * this.width / 2,\n        y: (1 - viewportPos.y) * this.height / 2\n      };\n    }\n\n    /**\n     * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n  }, {\n    key: \"viewportToFramedGraph\",\n    value: function viewportToFramedGraph(coordinates) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;\n      var invMatrix = override.matrix ? override.matrix : recomputeMatrix ? matrixFromCamera(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getStagePadding(), true) : this.invMatrix;\n      var res = multiplyVec2(invMatrix, {\n        x: coordinates.x / this.width * 2 - 1,\n        y: 1 - coordinates.y / this.height * 2\n      });\n      if (isNaN(res.x)) res.x = 0;\n      if (isNaN(res.y)) res.y = 0;\n      return res;\n    }\n\n    /**\n     * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the\n     * stage) to the graph system (the reference system of data as they are in the given graph instance).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  viewportPoint\n     * @param {CoordinateConversionOverride} override\n     */\n  }, {\n    key: \"viewportToGraph\",\n    value: function viewportToGraph(viewportPoint) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));\n    }\n\n    /**\n     * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in\n     * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  graphPoint\n     * @param {CoordinateConversionOverride} override\n     */\n  }, {\n    key: \"graphToViewport\",\n    value: function graphToViewport(graphPoint) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);\n    }\n\n    /**\n     * Method returning the distance multiplier between the graph system and the\n     * viewport system.\n     */\n  }, {\n    key: \"getGraphToViewportRatio\",\n    value: function getGraphToViewportRatio() {\n      var graphP1 = {\n        x: 0,\n        y: 0\n      };\n      var graphP2 = {\n        x: 1,\n        y: 1\n      };\n      var graphD = Math.sqrt(Math.pow(graphP1.x - graphP2.x, 2) + Math.pow(graphP1.y - graphP2.y, 2));\n      var viewportP1 = this.graphToViewport(graphP1);\n      var viewportP2 = this.graphToViewport(graphP2);\n      var viewportD = Math.sqrt(Math.pow(viewportP1.x - viewportP2.x, 2) + Math.pow(viewportP1.y - viewportP2.y, 2));\n      return viewportD / graphD;\n    }\n\n    /**\n     * Method returning the graph's bounding box.\n     *\n     * @return {{ x: Extent, y: Extent }}\n     */\n  }, {\n    key: \"getBBox\",\n    value: function getBBox() {\n      return this.nodeExtent;\n    }\n\n    /**\n     * Method returning the graph's custom bounding box, if any.\n     *\n     * @return {{ x: Extent, y: Extent } | null}\n     */\n  }, {\n    key: \"getCustomBBox\",\n    value: function getCustomBBox() {\n      return this.customBBox;\n    }\n\n    /**\n     * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setCustomBBox\",\n    value: function setCustomBBox(customBBox) {\n      this.customBBox = customBBox;\n      this.scheduleRender();\n      return this;\n    }\n\n    /**\n     * Method used to shut the container & release event listeners.\n     *\n     * @return {undefined}\n     */\n  }, {\n    key: \"kill\",\n    value: function kill() {\n      // Emitting \"kill\" events so that plugins and such can cleanup\n      this.emit(\"kill\");\n\n      // Releasing events\n      this.removeAllListeners();\n\n      // Releasing camera handlers\n      this.unbindCameraHandlers();\n\n      // Releasing DOM events & captors\n      window.removeEventListener(\"resize\", this.activeListeners.handleResize);\n      this.mouseCaptor.kill();\n      this.touchCaptor.kill();\n\n      // Releasing graph handlers\n      this.unbindGraphHandlers();\n\n      // Releasing cache & state\n      this.clearIndices();\n      this.clearState();\n      this.nodeDataCache = {};\n      this.edgeDataCache = {};\n      this.highlightedNodes.clear();\n\n      // Clearing frames\n      if (this.renderFrame) {\n        cancelAnimationFrame(this.renderFrame);\n        this.renderFrame = null;\n      }\n      if (this.renderHighlightedNodesFrame) {\n        cancelAnimationFrame(this.renderHighlightedNodesFrame);\n        this.renderHighlightedNodesFrame = null;\n      }\n\n      // Destroying canvases\n      var container = this.container;\n      while (container.firstChild) container.removeChild(container.firstChild);\n\n      // Destroying remaining collections\n      this.canvasContexts = {};\n      this.webGLContexts = {};\n      this.elements = {};\n\n      // Kill programs:\n      for (var type in this.nodePrograms) {\n        this.nodePrograms[type].kill();\n      }\n      for (var _type8 in this.nodeHoverPrograms) {\n        this.nodeHoverPrograms[_type8].kill();\n      }\n      for (var _type9 in this.edgePrograms) {\n        this.edgePrograms[_type9].kill();\n      }\n      this.nodePrograms = {};\n      this.nodeHoverPrograms = {};\n      this.edgePrograms = {};\n\n      // Kill all canvas/WebGL contexts\n      for (var id in this.elements) {\n        this.killLayer(id);\n      }\n    }\n\n    /**\n     * Method used to scale the given size according to the camera's ratio, i.e.\n     * zooming state.\n     *\n     * @param  {number?} size -        The size to scale (node size, edge thickness etc.).\n     * @param  {number?} cameraRatio - A camera ratio (defaults to the actual camera ratio).\n     * @return {number}              - The scaled size.\n     */\n  }, {\n    key: \"scaleSize\",\n    value: function scaleSize() {\n      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var cameraRatio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.camera.ratio;\n      return size / this.settings.zoomToSizeRatioFunction(cameraRatio) * (this.getSetting(\"itemSizesReference\") === \"positions\" ? cameraRatio * this.graphToViewportRatio : 1);\n    }\n\n    /**\n     * Method that returns the collection of all used canvases.\n     * At the moment, the instantiated canvases are the following, and in the\n     * following order in the DOM:\n     * - `edges`\n     * - `nodes`\n     * - `edgeLabels`\n     * - `labels`\n     * - `hovers`\n     * - `hoverNodes`\n     * - `mouse`\n     *\n     * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.\n     */\n  }, {\n    key: \"getCanvases\",\n    value: function getCanvases() {\n      return _objectSpread2({}, this.elements);\n    }\n  }]);\n  return Sigma;\n}(TypedEventEmitter);\n\n/**\n * Sigma.js Library Endpoint\n * =========================\n *\n * The library endpoint.\n * @module\n */\nvar Sigma = Sigma$1;\nexport { Camera, MouseCaptor, Sigma$1 as Sigma, TouchCaptor, Sigma as default };","map":{"version":3,"names":["_","_defineProperty","a","_objectSpread2","_inherits","_classCallCheck","b","_callSuper","c","_assertThisInitialized","d","_createClass","t","toPropertyKey","TypedEventEmitter","A","ANIMATE_DEFAULTS","e","easings","i","identity","createNormalizationFunction","g","getPixelRatio","v","validateGraph","graphExtent","m","matrixFromCamera","z","zIndexOrdering","getMatrixImpact","createElement","f","multiplyVec2","DEFAULT_SETTINGS","resolveSettings","validateSettings","_slicedToArray","_arrayLikeToArray","_unsupportedIterableToArray","getPixelColor","colorToIndex","extend","DEFAULT_ZOOMING_RATIO","Camera","_TypedEventEmitter","_this","previousState","getState","key","value","enable","enabled","disable","x","y","angle","ratio","hasState","state","getPreviousState","getBoundedRatio","r","minRatio","Math","max","maxRatio","min","validateState","validatedState","enabledRotation","isAnimated","nextFrame","setState","validState","emit","updateState","updater","animate","_this2","opts","arguments","length","undefined","callback","Promise","resolve","options","easing","start","Date","now","initialState","fn","duration","animationCallback","call","coefficient","newState","requestAnimationFrame","cancelAnimationFrame","animatedZoom","factorOrOptions","factor","animatedUnzoom","animatedReset","copy","from","camera","getPosition","dom","bbox","getBoundingClientRect","clientX","left","clientY","top","getMouseCoords","res","sigmaDefaultPrevented","preventSigmaDefault","original","getWheelCoords","delta","getWheelDelta","MAX_TOUCHES","getTouchesArray","touches","arr","l","push","getTouchCoords","map","touch","deltaY","detail","Error","Captor","container","renderer","MOUSE_SETTINGS_KEYS","DEFAULT_MOUSE_SETTINGS","reduce","iter","MouseCaptor","_Captor","handleClick","bind","handleRightClick","handleDown","handleUp","handleMove","handleWheel","handleLeave","handleEnter","addEventListener","document","kill","removeEventListener","clicks","doubleClickTimeout","clearTimeout","handleDoubleClick","setTimeout","settings","draggedEvents","draggedEventsTolerance","preventDefault","stopPropagation","mouseCoords","getCamera","newRatio","doubleClickZoomingRatio","getViewportZoomedState","doubleClickZoomingDuration","button","startCameraState","_getPosition","lastMouseX","lastMouseY","downStartTime","isMouseDown","_this3","movingTimeout","_getPosition2","cameraState","previousCameraState","isMoving","inertiaRatio","inertiaDuration","shouldRefresh","refresh","_this4","target","composedPath","window","dragTimeout","_getPosition3","eX","eY","lastMouse","viewportToFramedGraph","mouse","offsetX","offsetY","_this5","wheelCoords","ratioDiff","zoomingRatio","wheelDirection","currentWheelDirection","lastWheelTriggerTime","zoomDuration","setSettings","TOUCH_SETTINGS_KEYS","DEFAULT_TOUCH_SETTINGS","TouchCaptor","handleStart","getDimensions","width","offsetWidth","height","offsetHeight","dispatchRelatedMouseEvent","type","emitter","mousePosition","mouseEvent","MouseEvent","altKey","ctrlKey","isFakeSigmaMouseEvent","dispatchEvent","touchMode","startTouchesPositions","lastTouches","lastTouchesPositions","_this$startTouchesPos","_this$startTouchesPos2","x0","y0","_this$startTouchesPos3","x1","y1","startTouchesAngle","atan2","startTouchesDistance","sqrt","pow","hasMoved","touchesPositions","some","position","idx","startPosition","_this$renderer$viewpo","xStart","yStart","_this$renderer$viewpo2","newCameraState","_touchesPositions$","_touchesPositions$2","angleDiff","hypot","dimensions","touchGraphPosition","smallestDimension","dx","dy","_x","_y","_ref","cos","sin","_arrayWithoutHoles","Array","isArray","_iterableToArray","Symbol","iterator","_nonIterableSpread","TypeError","_toConsumableArray","_objectWithoutPropertiesLoose","source","excluded","sourceKeys","Object","keys","indexOf","_objectWithoutProperties","getOwnPropertySymbols","sourceSymbolKeys","prototype","propertyIsEnumerable","LabelCandidate","size","compare","first","second","LabelGrid","resizeAndClear","cellSize","columns","ceil","rows","cells","getIndex","pos","xIndex","floor","yIndex","add","candidate","index","cell","organize","k","sort","getLabelsToDisplay","density","cellArea","scaledCellArea","scaledDensity","labelsToDisplayPerCell","labels","edgeLabelsToDisplayFromNodes","params","graph","hoveredNode","highlightedNodes","displayedNodeLabels","worthyEdges","forEachEdge","edge","has","X_LABEL_MARGIN","Y_LABEL_MARGIN","hasOwnProperty","applyNodeDefaults","data","concat","color","defaultNodeColor","label","hidden","highlighted","forceLabel","defaultNodeType","zIndex","applyEdgeDefaults","_key","defaultEdgeColor","defaultEdgeType","Sigma$1","Sigma","Set","Infinity","pixelRatio","HTMLElement","createWebGLContext","picking","enableEdgeEvents","createCanvasContext","resize","nodeProgramClasses","registerNodeProgram","nodeHoverProgramClasses","_type","edgeProgramClasses","registerEdgeProgram","bindCameraHandlers","mouseCaptor","elements","touchCaptor","bindEventHandlers","bindGraphHandlers","handleSettingsUpdate","NodeProgramClass","NodeHoverProgram","nodePrograms","nodeHoverPrograms","webGLContexts","nodes","frameBuffers","hoverNodes","EdgeProgramClass","edgePrograms","edges","unregisterNodeProgram","_this$nodePrograms","program","programs","_this$nodeHoverProgra","_program","_programs","unregisterEdgeProgram","_this$edgePrograms","resetWebGLTexture","id","gl","frameBuffer","currentTexture","textures","deleteTexture","pickingTexture","createTexture","bindFramebuffer","FRAMEBUFFER","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","framebufferTexture2D","COLOR_ATTACHMENT0","activeListeners","scheduleRender","on","unbindCameraHandlers","removeListener","getNodeAtPosition","pickingDownSizingRatio","apply","itemAt","itemIDsIndex","handleResize","scheduleRefresh","baseEvent","event","nodeToHover","nodeDataCache","node","scheduleHighlightedNodesRender","edgeToHover","getEdgeAtPoint","hoveredEdge","createMouseListener","eventType","nodeAtPosition","LAYOUT_IMPACTING_FIELDS","eachNodeAttributesUpdatedGraphUpdate","_e$hints","updatedFields","hints","attributes","forEachNode","updateNode","layoutChanged","partialGraph","skipIndexation","schedule","eachEdgeAttributesUpdatedGraphUpdate","_e$hints2","updateEdge","includes","addNodeGraphUpdate","payload","addNode","updateNodeGraphUpdate","dropNodeGraphUpdate","removeNode","addEdgeGraphUpdate","addEdge","updateEdgeGraphUpdate","dropEdgeGraphUpdate","removeEdge","clearEdgesGraphUpdate","clearEdgeState","clearEdgeIndices","clearGraphUpdate","clearNodeState","clearNodeIndices","unbindGraphHandlers","process","nodeExtent","autoRescale","_this$nodeExtent","normalizationFunction","customBBox","nullCamera","nullCameraMatrix","getGraphDimensions","getStagePadding","labelGrid","labelGridCellSize","nodesPerPrograms","nodeIndices","edgeIndices","incrID","attrs","getNodeAttributes","applyTo","framedGraphToViewport","matrix","reallocate","nodeZExtent","_i","_l","_node","_data","addNodeToProgram","edgesPerPrograms","_i2","_l2","_data2","edgeDataCache","edgeZExtent","_type2","_i3","_l3","_edge","_data3","addEdgeToProgram","oldSettings","minCameraRatio","maxCameraRatio","enableCameraRotation","_type3","_type4","_type5","renderLabels","labelsToDisplay","labelDensity","nodesWithForcedLabels","context","canvasContexts","_this$framedGraphToVi","scaleSize","labelRenderedSizeThreshold","defaultDrawNodeLabel","nodeProgram","drawLabel","renderEdgeLabels","edgeLabels","clearRect","edgeLabelsToDisplay","edgesWithForcedLabels","displayedLabels","extremities","sourceData","targetData","edgeData","defaultDrawEdgeLabel","edgeProgram","displayedEdgeLabels","renderHighlightedNodes","_this6","hovers","render","_this6$framedGraphToV","defaultDrawNodeHover","drawHover","nodesToRender","forEach","clear","COLOR_BUFFER_BIT","renderParams","getRenderParams","_type6","_this7","renderHighlightedNodesFrame","renderFrame","_this8","exitRender","needToProcess","pickingLayers","layer","order","moving","viewportDimensions","graphDimensions","padding","invMatrix","correctionRatio","graphToViewportRatio","getGraphToViewportRatio","hideEdgesOnMove","_type7","_program2","hideLabelsOnMove","attr","assign","nodeReducer","nodeProgramIndex","getEdgeAttributes","edgeReducer","edgeProgramIndex","clearIndices","clearState","fingerprint","zoomRatio","cameraAngle","sizeRatio","downSizingRatio","minEdgeThickness","antiAliasingFeather","_this$settings","stagePadding","createCanvas","canvas","beforeLayer","before","afterLayer","after","appendChild","contextOptions","preserveDrawingBuffer","antialias","getContext","remove","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","newFrameBuffer","createFramebuffer","killLayer","_gl$getExtension","getExtension","loseContext","setCamera","getContainer","getGraph","setGraph","checkEdgesEventsFrame","getMouseCaptor","getTouchCaptor","extent","getNodeDisplayData","getEdgeDisplayData","getNodeDisplayedLabels","getEdgeDisplayedLabels","getSettings","getSetting","setSetting","oldValues","updateSetting","force","previousWidth","previousHeight","allowInvalidContainer","element","style","_id","setAttribute","scale","_id2","viewport","WebGLRenderingContext","_this9","fullRefresh","_opts$partialGraph","_opts$partialGraph2","programIndex","_i4","_l4","_programIndex","_this10","viewportTarget","_this$camera$getState","_this$settings2","center","graphMousePosition","graphCenterPosition","viewRectangle","p1","p2","h","x2","y2","coordinates","override","recomputeMatrix","viewportPos","isNaN","viewportToGraph","viewportPoint","inverse","graphToViewport","graphPoint","graphP1","graphP2","graphD","viewportP1","viewportP2","viewportD","getBBox","getCustomBBox","setCustomBBox","removeAllListeners","firstChild","removeChild","_type8","_type9","cameraRatio","zoomToSizeRatioFunction","getCanvases","default"],"sources":["D:/code/JazzSigma/node_modules/sigma/dist/sigma.esm.js"],"sourcesContent":["import { _ as _defineProperty, a as _objectSpread2 } from './index-ffa87df4.esm.js';\nimport { _ as _inherits, a as _classCallCheck, b as _callSuper, c as _assertThisInitialized, d as _createClass, t as toPropertyKey } from './inherits-45ee1abe.esm.js';\nimport { TypedEventEmitter } from '../types/dist/sigma-types.esm.js';\nimport { A as ANIMATE_DEFAULTS, e as easings, i as identity, c as createNormalizationFunction, g as getPixelRatio, v as validateGraph, a as graphExtent, m as matrixFromCamera, z as zIndexOrdering, b as getMatrixImpact, d as createElement, f as multiplyVec2 } from './normalization-6ad2dc39.esm.js';\nimport { DEFAULT_SETTINGS, resolveSettings, validateSettings } from '../settings/dist/sigma-settings.esm.js';\nimport { _ as _slicedToArray, a as _arrayLikeToArray, b as _unsupportedIterableToArray, g as getPixelColor, c as colorToIndex } from './colors-2f6d17f0.esm.js';\nimport { e as extend } from './data-31990a76.esm.js';\nimport 'events';\nimport 'graphology-utils/is-graph';\n\n/**\n * Defaults.\n */\nvar DEFAULT_ZOOMING_RATIO = 1.5;\n\n/**\n * Event types.\n */\n/**\n * Camera class\n */\nvar Camera = /*#__PURE__*/function (_TypedEventEmitter) {\n  _inherits(Camera, _TypedEventEmitter);\n  function Camera() {\n    var _this;\n    _classCallCheck(this, Camera);\n    _this = _callSuper(this, Camera);\n\n    // State\n    _defineProperty(_assertThisInitialized(_this), \"x\", 0.5);\n    _defineProperty(_assertThisInitialized(_this), \"y\", 0.5);\n    _defineProperty(_assertThisInitialized(_this), \"angle\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"ratio\", 1);\n    _defineProperty(_assertThisInitialized(_this), \"minRatio\", null);\n    _defineProperty(_assertThisInitialized(_this), \"maxRatio\", null);\n    _defineProperty(_assertThisInitialized(_this), \"enabledRotation\", true);\n    _defineProperty(_assertThisInitialized(_this), \"nextFrame\", null);\n    _defineProperty(_assertThisInitialized(_this), \"previousState\", null);\n    _defineProperty(_assertThisInitialized(_this), \"enabled\", true);\n    _this.previousState = _this.getState();\n    return _this;\n  }\n\n  /**\n   * Static method used to create a Camera object with a given state.\n   */\n  _createClass(Camera, [{\n    key: \"enable\",\n    value:\n    /**\n     * Method used to enable the camera.\n     */\n    function enable() {\n      this.enabled = true;\n      return this;\n    }\n\n    /**\n     * Method used to disable the camera.\n     */\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.enabled = false;\n      return this;\n    }\n\n    /**\n     * Method used to retrieve the camera's current state.\n     */\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return {\n        x: this.x,\n        y: this.y,\n        angle: this.angle,\n        ratio: this.ratio\n      };\n    }\n\n    /**\n     * Method used to check whether the camera has the given state.\n     */\n  }, {\n    key: \"hasState\",\n    value: function hasState(state) {\n      return this.x === state.x && this.y === state.y && this.ratio === state.ratio && this.angle === state.angle;\n    }\n\n    /**\n     * Method used to retrieve the camera's previous state.\n     */\n  }, {\n    key: \"getPreviousState\",\n    value: function getPreviousState() {\n      var state = this.previousState;\n      if (!state) return null;\n      return {\n        x: state.x,\n        y: state.y,\n        angle: state.angle,\n        ratio: state.ratio\n      };\n    }\n\n    /**\n     * Method used to check minRatio and maxRatio values.\n     */\n  }, {\n    key: \"getBoundedRatio\",\n    value: function getBoundedRatio(ratio) {\n      var r = ratio;\n      if (typeof this.minRatio === \"number\") r = Math.max(r, this.minRatio);\n      if (typeof this.maxRatio === \"number\") r = Math.min(r, this.maxRatio);\n      return r;\n    }\n\n    /**\n     * Method used to check various things to return a legit state candidate.\n     */\n  }, {\n    key: \"validateState\",\n    value: function validateState(state) {\n      var validatedState = {};\n      if (typeof state.x === \"number\") validatedState.x = state.x;\n      if (typeof state.y === \"number\") validatedState.y = state.y;\n      if (this.enabledRotation && typeof state.angle === \"number\") validatedState.angle = state.angle;\n      if (typeof state.ratio === \"number\") validatedState.ratio = this.getBoundedRatio(state.ratio);\n      return validatedState;\n    }\n\n    /**\n     * Method used to check whether the camera is currently being animated.\n     */\n  }, {\n    key: \"isAnimated\",\n    value: function isAnimated() {\n      return !!this.nextFrame;\n    }\n\n    /**\n     * Method used to set the camera's state.\n     */\n  }, {\n    key: \"setState\",\n    value: function setState(state) {\n      if (!this.enabled) return this;\n\n      // Keeping track of last state\n      this.previousState = this.getState();\n      var validState = this.validateState(state);\n      if (typeof validState.x === \"number\") this.x = validState.x;\n      if (typeof validState.y === \"number\") this.y = validState.y;\n      if (this.enabledRotation && typeof validState.angle === \"number\") this.angle = validState.angle;\n      if (typeof validState.ratio === \"number\") this.ratio = validState.ratio;\n\n      // Emitting\n      if (!this.hasState(this.previousState)) this.emit(\"updated\", this.getState());\n      return this;\n    }\n\n    /**\n     * Method used to update the camera's state using a function.\n     */\n  }, {\n    key: \"updateState\",\n    value: function updateState(updater) {\n      this.setState(updater(this.getState()));\n      return this;\n    }\n\n    /**\n     * Method used to animate the camera.\n     */\n  }, {\n    key: \"animate\",\n    value: function animate(state) {\n      var _this2 = this;\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var callback = arguments.length > 2 ? arguments[2] : undefined;\n      if (!callback) return new Promise(function (resolve) {\n        return _this2.animate(state, opts, resolve);\n      });\n      if (!this.enabled) return;\n      var options = _objectSpread2(_objectSpread2({}, ANIMATE_DEFAULTS), opts);\n      var validState = this.validateState(state);\n      var easing = typeof options.easing === \"function\" ? options.easing : easings[options.easing];\n\n      // State\n      var start = Date.now(),\n        initialState = this.getState();\n\n      // Function performing the animation\n      var fn = function fn() {\n        var t = (Date.now() - start) / options.duration;\n\n        // The animation is over:\n        if (t >= 1) {\n          _this2.nextFrame = null;\n          _this2.setState(validState);\n          if (_this2.animationCallback) {\n            _this2.animationCallback.call(null);\n            _this2.animationCallback = undefined;\n          }\n          return;\n        }\n        var coefficient = easing(t);\n        var newState = {};\n        if (typeof validState.x === \"number\") newState.x = initialState.x + (validState.x - initialState.x) * coefficient;\n        if (typeof validState.y === \"number\") newState.y = initialState.y + (validState.y - initialState.y) * coefficient;\n        if (_this2.enabledRotation && typeof validState.angle === \"number\") newState.angle = initialState.angle + (validState.angle - initialState.angle) * coefficient;\n        if (typeof validState.ratio === \"number\") newState.ratio = initialState.ratio + (validState.ratio - initialState.ratio) * coefficient;\n        _this2.setState(newState);\n        _this2.nextFrame = requestAnimationFrame(fn);\n      };\n      if (this.nextFrame) {\n        cancelAnimationFrame(this.nextFrame);\n        if (this.animationCallback) this.animationCallback.call(null);\n        this.nextFrame = requestAnimationFrame(fn);\n      } else {\n        fn();\n      }\n      this.animationCallback = callback;\n    }\n\n    /**\n     * Method used to zoom the camera.\n     */\n  }, {\n    key: \"animatedZoom\",\n    value: function animatedZoom(factorOrOptions) {\n      if (!factorOrOptions) return this.animate({\n        ratio: this.ratio / DEFAULT_ZOOMING_RATIO\n      });\n      if (typeof factorOrOptions === \"number\") return this.animate({\n        ratio: this.ratio / factorOrOptions\n      });\n      return this.animate({\n        ratio: this.ratio / (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n      }, factorOrOptions);\n    }\n\n    /**\n     * Method used to unzoom the camera.\n     */\n  }, {\n    key: \"animatedUnzoom\",\n    value: function animatedUnzoom(factorOrOptions) {\n      if (!factorOrOptions) return this.animate({\n        ratio: this.ratio * DEFAULT_ZOOMING_RATIO\n      });\n      if (typeof factorOrOptions === \"number\") return this.animate({\n        ratio: this.ratio * factorOrOptions\n      });\n      return this.animate({\n        ratio: this.ratio * (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n      }, factorOrOptions);\n    }\n\n    /**\n     * Method used to reset the camera.\n     */\n  }, {\n    key: \"animatedReset\",\n    value: function animatedReset(options) {\n      return this.animate({\n        x: 0.5,\n        y: 0.5,\n        ratio: 1,\n        angle: 0\n      }, options);\n    }\n\n    /**\n     * Returns a new Camera instance, with the same state as the current camera.\n     */\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return Camera.from(this.getState());\n    }\n  }], [{\n    key: \"from\",\n    value: function from(state) {\n      var camera = new Camera();\n      return camera.setState(state);\n    }\n  }]);\n  return Camera;\n}(TypedEventEmitter);\n\n/**\n * Captor utils functions\n * ======================\n */\n\n/**\n * Extract the local X and Y coordinates from a mouse event or touch object. If\n * a DOM element is given, it uses this element's offset to compute the position\n * (this allows using events that are not bound to the container itself and\n * still have a proper position).\n *\n * @param  {event}       e - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {number}      The local Y value of the mouse.\n */\nfunction getPosition(e, dom) {\n  var bbox = dom.getBoundingClientRect();\n  return {\n    x: e.clientX - bbox.left,\n    y: e.clientY - bbox.top\n  };\n}\n\n/**\n * Convert mouse coords to sigma coords.\n *\n * @param  {event}       e   - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getMouseCoords(e, dom) {\n  var res = _objectSpread2(_objectSpread2({}, getPosition(e, dom)), {}, {\n    sigmaDefaultPrevented: false,\n    preventSigmaDefault: function preventSigmaDefault() {\n      res.sigmaDefaultPrevented = true;\n    },\n    original: e\n  });\n  return res;\n}\n\n/**\n * Convert mouse wheel event coords to sigma coords.\n *\n * @param  {event}       e   - A wheel mouse event.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getWheelCoords(e, dom) {\n  return _objectSpread2(_objectSpread2({}, getMouseCoords(e, dom)), {}, {\n    delta: getWheelDelta(e)\n  });\n}\nvar MAX_TOUCHES = 2;\nfunction getTouchesArray(touches) {\n  var arr = [];\n  for (var i = 0, l = Math.min(touches.length, MAX_TOUCHES); i < l; i++) arr.push(touches[i]);\n  return arr;\n}\n\n/**\n * Convert touch coords to sigma coords.\n *\n * @param  {event}       e   - A touch event.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getTouchCoords(e, dom) {\n  return {\n    touches: getTouchesArray(e.touches).map(function (touch) {\n      return getPosition(touch, dom);\n    }),\n    original: e\n  };\n}\n\n/**\n * Extract the wheel delta from a mouse event or touch object.\n *\n * @param  {event}  e - A mouse event or touch object.\n * @return {number}     The wheel delta of the mouse.\n */\nfunction getWheelDelta(e) {\n  // TODO: check those ratios again to ensure a clean Chrome/Firefox compat\n  if (typeof e.deltaY !== \"undefined\") return e.deltaY * -3 / 360;\n  if (typeof e.detail !== \"undefined\") return e.detail / -9;\n  throw new Error(\"Captor: could not extract delta from event.\");\n}\n\n/**\n * Abstract class representing a captor like the user's mouse or touch controls.\n */\nvar Captor = /*#__PURE__*/function (_TypedEventEmitter) {\n  _inherits(Captor, _TypedEventEmitter);\n  function Captor(container, renderer) {\n    var _this;\n    _classCallCheck(this, Captor);\n    _this = _callSuper(this, Captor);\n    // Properties\n    _this.container = container;\n    _this.renderer = renderer;\n    return _this;\n  }\n  return _createClass(Captor);\n}(TypedEventEmitter);\n\nvar MOUSE_SETTINGS_KEYS = [\"doubleClickTimeout\", \"doubleClickZoomingDuration\", \"doubleClickZoomingRatio\", \"dragTimeout\", \"draggedEventsTolerance\", \"inertiaDuration\", \"inertiaRatio\", \"zoomDuration\", \"zoomingRatio\"];\nvar DEFAULT_MOUSE_SETTINGS = MOUSE_SETTINGS_KEYS.reduce(function (iter, key) {\n  return _objectSpread2(_objectSpread2({}, iter), {}, _defineProperty({}, key, DEFAULT_SETTINGS[key]));\n}, {});\n\n/**\n * Event types.\n */\n/**\n * Mouse captor class.\n *\n * @constructor\n */\nvar MouseCaptor = /*#__PURE__*/function (_Captor) {\n  _inherits(MouseCaptor, _Captor);\n  function MouseCaptor(container, renderer) {\n    var _this;\n    _classCallCheck(this, MouseCaptor);\n    _this = _callSuper(this, MouseCaptor, [container, renderer]);\n\n    // Binding methods\n    // State\n    _defineProperty(_assertThisInitialized(_this), \"enabled\", true);\n    _defineProperty(_assertThisInitialized(_this), \"draggedEvents\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"downStartTime\", null);\n    _defineProperty(_assertThisInitialized(_this), \"lastMouseX\", null);\n    _defineProperty(_assertThisInitialized(_this), \"lastMouseY\", null);\n    _defineProperty(_assertThisInitialized(_this), \"isMouseDown\", false);\n    _defineProperty(_assertThisInitialized(_this), \"isMoving\", false);\n    _defineProperty(_assertThisInitialized(_this), \"movingTimeout\", null);\n    _defineProperty(_assertThisInitialized(_this), \"startCameraState\", null);\n    _defineProperty(_assertThisInitialized(_this), \"clicks\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"doubleClickTimeout\", null);\n    _defineProperty(_assertThisInitialized(_this), \"currentWheelDirection\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"settings\", DEFAULT_MOUSE_SETTINGS);\n    _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_this));\n    _this.handleRightClick = _this.handleRightClick.bind(_assertThisInitialized(_this));\n    _this.handleDown = _this.handleDown.bind(_assertThisInitialized(_this));\n    _this.handleUp = _this.handleUp.bind(_assertThisInitialized(_this));\n    _this.handleMove = _this.handleMove.bind(_assertThisInitialized(_this));\n    _this.handleWheel = _this.handleWheel.bind(_assertThisInitialized(_this));\n    _this.handleLeave = _this.handleLeave.bind(_assertThisInitialized(_this));\n    _this.handleEnter = _this.handleEnter.bind(_assertThisInitialized(_this));\n\n    // Binding events\n    container.addEventListener(\"click\", _this.handleClick, false);\n    container.addEventListener(\"contextmenu\", _this.handleRightClick, false);\n    container.addEventListener(\"mousedown\", _this.handleDown, false);\n    container.addEventListener(\"wheel\", _this.handleWheel, false);\n    container.addEventListener(\"mouseleave\", _this.handleLeave, false);\n    container.addEventListener(\"mouseenter\", _this.handleEnter, false);\n    document.addEventListener(\"mousemove\", _this.handleMove, false);\n    document.addEventListener(\"mouseup\", _this.handleUp, false);\n    return _this;\n  }\n  _createClass(MouseCaptor, [{\n    key: \"kill\",\n    value: function kill() {\n      var container = this.container;\n      container.removeEventListener(\"click\", this.handleClick);\n      container.removeEventListener(\"contextmenu\", this.handleRightClick);\n      container.removeEventListener(\"mousedown\", this.handleDown);\n      container.removeEventListener(\"wheel\", this.handleWheel);\n      container.removeEventListener(\"mouseleave\", this.handleLeave);\n      container.removeEventListener(\"mouseenter\", this.handleEnter);\n      document.removeEventListener(\"mousemove\", this.handleMove);\n      document.removeEventListener(\"mouseup\", this.handleUp);\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(e) {\n      var _this2 = this;\n      if (!this.enabled) return;\n      this.clicks++;\n      if (this.clicks === 2) {\n        this.clicks = 0;\n        if (typeof this.doubleClickTimeout === \"number\") {\n          clearTimeout(this.doubleClickTimeout);\n          this.doubleClickTimeout = null;\n        }\n        return this.handleDoubleClick(e);\n      }\n      setTimeout(function () {\n        _this2.clicks = 0;\n        _this2.doubleClickTimeout = null;\n      }, this.settings.doubleClickTimeout);\n\n      // NOTE: this is here to prevent click events on drag\n      if (this.draggedEvents < this.settings.draggedEventsTolerance) this.emit(\"click\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleRightClick\",\n    value: function handleRightClick(e) {\n      if (!this.enabled) return;\n      this.emit(\"rightClick\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleDoubleClick\",\n    value: function handleDoubleClick(e) {\n      if (!this.enabled) return;\n      e.preventDefault();\n      e.stopPropagation();\n      var mouseCoords = getMouseCoords(e, this.container);\n      this.emit(\"doubleClick\", mouseCoords);\n      if (mouseCoords.sigmaDefaultPrevented) return;\n\n      // default behavior\n      var camera = this.renderer.getCamera();\n      var newRatio = camera.getBoundedRatio(camera.getState().ratio / this.settings.doubleClickZoomingRatio);\n      camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {\n        easing: \"quadraticInOut\",\n        duration: this.settings.doubleClickZoomingDuration\n      });\n    }\n  }, {\n    key: \"handleDown\",\n    value: function handleDown(e) {\n      if (!this.enabled) return;\n\n      // We only start dragging on left button\n      if (e.button === 0) {\n        this.startCameraState = this.renderer.getCamera().getState();\n        var _getPosition = getPosition(e, this.container),\n          x = _getPosition.x,\n          y = _getPosition.y;\n        this.lastMouseX = x;\n        this.lastMouseY = y;\n        this.draggedEvents = 0;\n        this.downStartTime = Date.now();\n        this.isMouseDown = true;\n      }\n      this.emit(\"mousedown\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleUp\",\n    value: function handleUp(e) {\n      var _this3 = this;\n      if (!this.enabled || !this.isMouseDown) return;\n      var camera = this.renderer.getCamera();\n      this.isMouseDown = false;\n      if (typeof this.movingTimeout === \"number\") {\n        clearTimeout(this.movingTimeout);\n        this.movingTimeout = null;\n      }\n      var _getPosition2 = getPosition(e, this.container),\n        x = _getPosition2.x,\n        y = _getPosition2.y;\n      var cameraState = camera.getState(),\n        previousCameraState = camera.getPreviousState() || {\n          x: 0,\n          y: 0\n        };\n      if (this.isMoving) {\n        camera.animate({\n          x: cameraState.x + this.settings.inertiaRatio * (cameraState.x - previousCameraState.x),\n          y: cameraState.y + this.settings.inertiaRatio * (cameraState.y - previousCameraState.y)\n        }, {\n          duration: this.settings.inertiaDuration,\n          easing: \"quadraticOut\"\n        });\n      } else if (this.lastMouseX !== x || this.lastMouseY !== y) {\n        camera.setState({\n          x: cameraState.x,\n          y: cameraState.y\n        });\n      }\n      this.isMoving = false;\n      setTimeout(function () {\n        var shouldRefresh = _this3.draggedEvents > 0;\n        _this3.draggedEvents = 0;\n\n        // NOTE: this refresh is here to make sure `hideEdgesOnMove` can work\n        // when someone releases camera pan drag after having stopped moving.\n        // See commit: https://github.com/jacomyal/sigma.js/commit/cfd9197f70319109db6b675dd7c82be493ca95a2\n        // See also issue: https://github.com/jacomyal/sigma.js/issues/1290\n        // It could be possible to render instead of scheduling a refresh but for\n        // now it seems good enough.\n        if (shouldRefresh) _this3.renderer.refresh();\n      }, 0);\n      this.emit(\"mouseup\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(e) {\n      var _this4 = this;\n      if (!this.enabled) return;\n      var mouseCoords = getMouseCoords(e, this.container);\n\n      // Always trigger a \"mousemovebody\" event, so that it is possible to develop\n      // a drag-and-drop effect that works even when the mouse is out of the\n      // container:\n      this.emit(\"mousemovebody\", mouseCoords);\n\n      // Only trigger the \"mousemove\" event when the mouse is actually hovering\n      // the container, to avoid weirdly hovering nodes and/or edges when the\n      // mouse is not hover the container:\n      if (e.target === this.container || e.composedPath()[0] === this.container) {\n        this.emit(\"mousemove\", mouseCoords);\n      }\n      if (mouseCoords.sigmaDefaultPrevented) return;\n\n      // Handle the case when \"isMouseDown\" all the time, to allow dragging the\n      // stage while the mouse is not hover the container:\n      if (this.isMouseDown) {\n        this.isMoving = true;\n        this.draggedEvents++;\n        if (typeof this.movingTimeout === \"number\") {\n          clearTimeout(this.movingTimeout);\n        }\n        this.movingTimeout = window.setTimeout(function () {\n          _this4.movingTimeout = null;\n          _this4.isMoving = false;\n        }, this.settings.dragTimeout);\n        var camera = this.renderer.getCamera();\n        var _getPosition3 = getPosition(e, this.container),\n          eX = _getPosition3.x,\n          eY = _getPosition3.y;\n        var lastMouse = this.renderer.viewportToFramedGraph({\n          x: this.lastMouseX,\n          y: this.lastMouseY\n        });\n        var mouse = this.renderer.viewportToFramedGraph({\n          x: eX,\n          y: eY\n        });\n        var offsetX = lastMouse.x - mouse.x,\n          offsetY = lastMouse.y - mouse.y;\n        var cameraState = camera.getState();\n        var x = cameraState.x + offsetX,\n          y = cameraState.y + offsetY;\n        camera.setState({\n          x: x,\n          y: y\n        });\n        this.lastMouseX = eX;\n        this.lastMouseY = eY;\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    }\n  }, {\n    key: \"handleLeave\",\n    value: function handleLeave(e) {\n      this.emit(\"mouseleave\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleEnter\",\n    value: function handleEnter(e) {\n      this.emit(\"mouseenter\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleWheel\",\n    value: function handleWheel(e) {\n      var _this5 = this;\n      if (!this.enabled) return;\n      e.preventDefault();\n      e.stopPropagation();\n      var delta = getWheelDelta(e);\n      if (!delta) return;\n      var wheelCoords = getWheelCoords(e, this.container);\n      this.emit(\"wheel\", wheelCoords);\n      if (wheelCoords.sigmaDefaultPrevented) return;\n\n      // Default behavior\n      var ratioDiff = delta > 0 ? 1 / this.settings.zoomingRatio : this.settings.zoomingRatio;\n      var camera = this.renderer.getCamera();\n      var newRatio = camera.getBoundedRatio(camera.getState().ratio * ratioDiff);\n      var wheelDirection = delta > 0 ? 1 : -1;\n      var now = Date.now();\n\n      // Cancel events that are too close too each other and in the same direction:\n      if (this.currentWheelDirection === wheelDirection && this.lastWheelTriggerTime && now - this.lastWheelTriggerTime < this.settings.zoomDuration / 5) {\n        return;\n      }\n      camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {\n        easing: \"quadraticOut\",\n        duration: this.settings.zoomDuration\n      }, function () {\n        _this5.currentWheelDirection = 0;\n      });\n      this.currentWheelDirection = wheelDirection;\n      this.lastWheelTriggerTime = now;\n    }\n  }, {\n    key: \"setSettings\",\n    value: function setSettings(settings) {\n      this.settings = settings;\n    }\n  }]);\n  return MouseCaptor;\n}(Captor);\n\nvar TOUCH_SETTINGS_KEYS = [\"dragTimeout\", \"inertiaDuration\", \"inertiaRatio\"];\nvar DEFAULT_TOUCH_SETTINGS = TOUCH_SETTINGS_KEYS.reduce(function (iter, key) {\n  return _objectSpread2(_objectSpread2({}, iter), {}, _defineProperty({}, key, DEFAULT_SETTINGS[key]));\n}, {});\n\n/**\n * Event types.\n */\n/**\n * Touch captor class.\n *\n * @constructor\n */\nvar TouchCaptor = /*#__PURE__*/function (_Captor) {\n  _inherits(TouchCaptor, _Captor);\n  function TouchCaptor(container, renderer) {\n    var _this;\n    _classCallCheck(this, TouchCaptor);\n    _this = _callSuper(this, TouchCaptor, [container, renderer]);\n\n    // Binding methods:\n    _defineProperty(_assertThisInitialized(_this), \"enabled\", true);\n    _defineProperty(_assertThisInitialized(_this), \"isMoving\", false);\n    _defineProperty(_assertThisInitialized(_this), \"hasMoved\", false);\n    _defineProperty(_assertThisInitialized(_this), \"touchMode\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"startTouchesPositions\", []);\n    _defineProperty(_assertThisInitialized(_this), \"settings\", DEFAULT_TOUCH_SETTINGS);\n    _this.handleStart = _this.handleStart.bind(_assertThisInitialized(_this));\n    _this.handleLeave = _this.handleLeave.bind(_assertThisInitialized(_this));\n    _this.handleMove = _this.handleMove.bind(_assertThisInitialized(_this));\n\n    // Binding events\n    container.addEventListener(\"touchstart\", _this.handleStart, false);\n    container.addEventListener(\"touchend\", _this.handleLeave, false);\n    container.addEventListener(\"touchcancel\", _this.handleLeave, false);\n    container.addEventListener(\"touchmove\", _this.handleMove, false);\n    return _this;\n  }\n  _createClass(TouchCaptor, [{\n    key: \"kill\",\n    value: function kill() {\n      var container = this.container;\n      container.removeEventListener(\"touchstart\", this.handleStart);\n      container.removeEventListener(\"touchend\", this.handleLeave);\n      container.removeEventListener(\"touchcancel\", this.handleLeave);\n      container.removeEventListener(\"touchmove\", this.handleMove);\n    }\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return {\n        width: this.container.offsetWidth,\n        height: this.container.offsetHeight\n      };\n    }\n  }, {\n    key: \"dispatchRelatedMouseEvent\",\n    value: function dispatchRelatedMouseEvent(type, e, touch, emitter) {\n      var mousePosition = touch || e.touches[0];\n      var mouseEvent = new MouseEvent(type, {\n        clientX: mousePosition.clientX,\n        clientY: mousePosition.clientY,\n        altKey: e.altKey,\n        ctrlKey: e.ctrlKey\n      });\n      mouseEvent.isFakeSigmaMouseEvent = true;\n      (emitter || this.container).dispatchEvent(mouseEvent);\n    }\n  }, {\n    key: \"handleStart\",\n    value: function handleStart(e) {\n      var _this2 = this;\n      if (!this.enabled) return;\n\n      // Prevent default to avoid default browser behaviors...\n      e.preventDefault();\n      // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n      if (e.touches.length === 1) this.dispatchRelatedMouseEvent(\"mousedown\", e);\n      var touches = getTouchesArray(e.touches);\n      this.touchMode = touches.length;\n      this.startCameraState = this.renderer.getCamera().getState();\n      this.startTouchesPositions = touches.map(function (touch) {\n        return getPosition(touch, _this2.container);\n      });\n      this.lastTouches = touches;\n      this.lastTouchesPositions = this.startTouchesPositions;\n\n      // When there are two touches down, let's record distance and angle as well:\n      if (this.touchMode === 2) {\n        var _this$startTouchesPos = _slicedToArray(this.startTouchesPositions, 2),\n          _this$startTouchesPos2 = _this$startTouchesPos[0],\n          x0 = _this$startTouchesPos2.x,\n          y0 = _this$startTouchesPos2.y,\n          _this$startTouchesPos3 = _this$startTouchesPos[1],\n          x1 = _this$startTouchesPos3.x,\n          y1 = _this$startTouchesPos3.y;\n        this.startTouchesAngle = Math.atan2(y1 - y0, x1 - x0);\n        this.startTouchesDistance = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n      }\n      this.emit(\"touchdown\", getTouchCoords(e, this.container));\n    }\n  }, {\n    key: \"handleLeave\",\n    value: function handleLeave(e) {\n      if (!this.enabled) return;\n\n      // Prevent default to avoid default browser behaviors...\n      e.preventDefault();\n      // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n      if (e.touches.length === 0 && this.lastTouches && this.lastTouches.length) {\n        this.dispatchRelatedMouseEvent(\"mouseup\", e, this.lastTouches[0], document);\n        // ... and only click if no move was made\n        if (!this.hasMoved) {\n          this.dispatchRelatedMouseEvent(\"click\", e, this.lastTouches[0]);\n        }\n      }\n      if (this.movingTimeout) {\n        this.isMoving = false;\n        clearTimeout(this.movingTimeout);\n      }\n      switch (this.touchMode) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        case 2:\n          if (e.touches.length === 1) {\n            this.handleStart(e);\n            e.preventDefault();\n            break;\n          }\n        /* falls through */\n        case 1:\n          // TODO\n          // Dispatch event\n\n          if (this.isMoving) {\n            var camera = this.renderer.getCamera();\n            var cameraState = camera.getState(),\n              previousCameraState = camera.getPreviousState() || {\n                x: 0,\n                y: 0\n              };\n            camera.animate({\n              x: cameraState.x + this.settings.inertiaRatio * (cameraState.x - previousCameraState.x),\n              y: cameraState.y + this.settings.inertiaRatio * (cameraState.y - previousCameraState.y)\n            }, {\n              duration: this.settings.inertiaDuration,\n              easing: \"quadraticOut\"\n            });\n          }\n          this.hasMoved = false;\n          this.isMoving = false;\n          this.touchMode = 0;\n          break;\n      }\n      this.emit(\"touchup\", getTouchCoords(e, this.container));\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(e) {\n      var _this3 = this;\n      if (!this.enabled) return;\n\n      // Prevent default to avoid default browser behaviors...\n      e.preventDefault();\n      // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n      if (e.touches.length === 1) this.dispatchRelatedMouseEvent(\"mousemove\", e);\n      var touches = getTouchesArray(e.touches);\n      var touchesPositions = touches.map(function (touch) {\n        return getPosition(touch, _this3.container);\n      });\n      this.lastTouches = touches;\n      this.lastTouchesPositions = touchesPositions;\n\n      // If a move was initiated at some point and we get back to startpoint,\n      // we should still consider that we did move (which also happens after a\n      // multiple touch when only one touch remains in which case handleStart\n      // is recalled within handleLeave).\n      // Now, some mobile browsers report zero-distance moves so we also check that\n      // one of the touches did actually move from the origin position.\n      this.hasMoved || (this.hasMoved = touchesPositions.some(function (position, idx) {\n        var startPosition = _this3.startTouchesPositions[idx];\n        return position.x !== startPosition.x || position.y !== startPosition.y;\n      }));\n\n      // If there was no move, do not trigger touch moves behavior\n      if (!this.hasMoved) {\n        return;\n      }\n      this.isMoving = true;\n      if (this.movingTimeout) clearTimeout(this.movingTimeout);\n      this.movingTimeout = window.setTimeout(function () {\n        _this3.isMoving = false;\n      }, this.settings.dragTimeout);\n      var camera = this.renderer.getCamera();\n      var startCameraState = this.startCameraState;\n      switch (this.touchMode) {\n        case 1:\n          {\n            var _this$renderer$viewpo = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0]),\n              xStart = _this$renderer$viewpo.x,\n              yStart = _this$renderer$viewpo.y;\n            var _this$renderer$viewpo2 = this.renderer.viewportToFramedGraph(touchesPositions[0]),\n              x = _this$renderer$viewpo2.x,\n              y = _this$renderer$viewpo2.y;\n            camera.setState({\n              x: startCameraState.x + xStart - x,\n              y: startCameraState.y + yStart - y\n            });\n            break;\n          }\n        case 2:\n          {\n            /**\n             * Here is the thinking here:\n             *\n             * 1. We can find the new angle and ratio, by comparing the vector from \"touch one\" to \"touch two\" at the start\n             *    of the d'n'd and now\n             *\n             * 2. We can use `Camera#viewportToGraph` inside formula to retrieve the new camera position, using the graph\n             *    position of a touch at the beginning of the d'n'd (using `startCamera.viewportToGraph`) and the viewport\n             *    position of this same touch now\n             */\n            var newCameraState = {};\n            var _touchesPositions$ = touchesPositions[0],\n              x0 = _touchesPositions$.x,\n              y0 = _touchesPositions$.y;\n            var _touchesPositions$2 = touchesPositions[1],\n              x1 = _touchesPositions$2.x,\n              y1 = _touchesPositions$2.y;\n            var angleDiff = Math.atan2(y1 - y0, x1 - x0) - this.startTouchesAngle;\n            var ratioDiff = Math.hypot(y1 - y0, x1 - x0) / this.startTouchesDistance;\n\n            // 1.\n            var newRatio = camera.getBoundedRatio(startCameraState.ratio / ratioDiff);\n            newCameraState.ratio = newRatio;\n            newCameraState.angle = startCameraState.angle + angleDiff;\n\n            // 2.\n            var dimensions = this.getDimensions();\n            var touchGraphPosition = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0], {\n              cameraState: startCameraState\n            });\n            var smallestDimension = Math.min(dimensions.width, dimensions.height);\n            var dx = smallestDimension / dimensions.width;\n            var dy = smallestDimension / dimensions.height;\n            var ratio = newRatio / smallestDimension;\n\n            // Align with center of the graph:\n            var _x = x0 - smallestDimension / 2 / dx;\n            var _y = y0 - smallestDimension / 2 / dy;\n\n            // Rotate:\n            var _ref = [_x * Math.cos(-newCameraState.angle) - _y * Math.sin(-newCameraState.angle), _y * Math.cos(-newCameraState.angle) + _x * Math.sin(-newCameraState.angle)];\n            _x = _ref[0];\n            _y = _ref[1];\n            newCameraState.x = touchGraphPosition.x - _x * ratio;\n            newCameraState.y = touchGraphPosition.y + _y * ratio;\n            camera.setState(newCameraState);\n            break;\n          }\n      }\n      this.emit(\"touchmove\", getTouchCoords(e, this.container));\n    }\n  }, {\n    key: \"setSettings\",\n    value: function setSettings(settings) {\n      this.settings = settings;\n    }\n  }]);\n  return TouchCaptor;\n}(Captor);\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\n/**\n * Sigma.js Labels Heuristics\n * ===========================\n *\n * Miscellaneous heuristics related to label display.\n * @module\n */\n/**\n * Class representing a single candidate for the label grid selection.\n *\n * It also describes a deterministic way to compare two candidates to assess\n * which one is better.\n */\nvar LabelCandidate = /*#__PURE__*/function () {\n  function LabelCandidate(key, size) {\n    _classCallCheck(this, LabelCandidate);\n    this.key = key;\n    this.size = size;\n  }\n  _createClass(LabelCandidate, null, [{\n    key: \"compare\",\n    value: function compare(first, second) {\n      // First we compare by size\n      if (first.size > second.size) return -1;\n      if (first.size < second.size) return 1;\n\n      // Then since no two nodes can have the same key, we use it to\n      // deterministically tie-break by key\n      if (first.key > second.key) return 1;\n\n      // NOTE: this comparator cannot return 0\n      return -1;\n    }\n  }]);\n  return LabelCandidate;\n}();\n/**\n * Class representing a 2D spatial grid divided into constant-size cells.\n */\nvar LabelGrid = /*#__PURE__*/function () {\n  function LabelGrid() {\n    _classCallCheck(this, LabelGrid);\n    _defineProperty(this, \"width\", 0);\n    _defineProperty(this, \"height\", 0);\n    _defineProperty(this, \"cellSize\", 0);\n    _defineProperty(this, \"columns\", 0);\n    _defineProperty(this, \"rows\", 0);\n    _defineProperty(this, \"cells\", {});\n  }\n  _createClass(LabelGrid, [{\n    key: \"resizeAndClear\",\n    value: function resizeAndClear(dimensions, cellSize) {\n      this.width = dimensions.width;\n      this.height = dimensions.height;\n      this.cellSize = cellSize;\n      this.columns = Math.ceil(dimensions.width / cellSize);\n      this.rows = Math.ceil(dimensions.height / cellSize);\n      this.cells = {};\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex(pos) {\n      var xIndex = Math.floor(pos.x / this.cellSize);\n      var yIndex = Math.floor(pos.y / this.cellSize);\n      return yIndex * this.columns + xIndex;\n    }\n  }, {\n    key: \"add\",\n    value: function add(key, size, pos) {\n      var candidate = new LabelCandidate(key, size);\n      var index = this.getIndex(pos);\n      var cell = this.cells[index];\n      if (!cell) {\n        cell = [];\n        this.cells[index] = cell;\n      }\n      cell.push(candidate);\n    }\n  }, {\n    key: \"organize\",\n    value: function organize() {\n      for (var k in this.cells) {\n        var cell = this.cells[k];\n        cell.sort(LabelCandidate.compare);\n      }\n    }\n  }, {\n    key: \"getLabelsToDisplay\",\n    value: function getLabelsToDisplay(ratio, density) {\n      // TODO: work on visible nodes to optimize? ^ -> threshold outside so that memoization works?\n      // TODO: adjust threshold lower, but increase cells a bit?\n      // TODO: hunt for geom issue in disguise\n      // TODO: memoize while ratio does not move. method to force recompute\n      var cellArea = this.cellSize * this.cellSize;\n      var scaledCellArea = cellArea / ratio / ratio;\n      var scaledDensity = scaledCellArea * density / cellArea;\n      var labelsToDisplayPerCell = Math.ceil(scaledDensity);\n      var labels = [];\n      for (var k in this.cells) {\n        var cell = this.cells[k];\n        for (var i = 0; i < Math.min(labelsToDisplayPerCell, cell.length); i++) {\n          labels.push(cell[i].key);\n        }\n      }\n      return labels;\n    }\n  }]);\n  return LabelGrid;\n}();\n\n/**\n * Label heuristic selecting edge labels to display, based on displayed node\n * labels\n *\n * @param  {object} params                 - Parameters:\n * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.\n * @param  {Set}      highlightedNodes     - Highlighted nodes.\n * @param  {Graph}    graph                - The rendered graph.\n * @param  {string}   hoveredNode          - Hovered node (optional)\n * @return {Array}                         - The selected labels.\n */\nfunction edgeLabelsToDisplayFromNodes(params) {\n  var graph = params.graph,\n    hoveredNode = params.hoveredNode,\n    highlightedNodes = params.highlightedNodes,\n    displayedNodeLabels = params.displayedNodeLabels;\n  var worthyEdges = [];\n\n  // TODO: the code below can be optimized using #.forEach and batching the code per adj\n\n  // We should display an edge's label if:\n  //   - Any of its extremities is highlighted or hovered\n  //   - Both of its extremities has its label shown\n  graph.forEachEdge(function (edge, _, source, target) {\n    if (source === hoveredNode || target === hoveredNode || highlightedNodes.has(source) || highlightedNodes.has(target) || displayedNodeLabels.has(source) && displayedNodeLabels.has(target)) {\n      worthyEdges.push(edge);\n    }\n  });\n  return worthyEdges;\n}\n\n/**\n * Constants.\n */\nvar X_LABEL_MARGIN = 150;\nvar Y_LABEL_MARGIN = 50;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Important functions.\n */\nfunction applyNodeDefaults(settings, key, data) {\n  if (!hasOwnProperty.call(data, \"x\") || !hasOwnProperty.call(data, \"y\")) throw new Error(\"Sigma: could not find a valid position (x, y) for node \\\"\".concat(key, \"\\\". All your nodes must have a number \\\"x\\\" and \\\"y\\\". Maybe your forgot to apply a layout or your \\\"nodeReducer\\\" is not returning the correct data?\"));\n  if (!data.color) data.color = settings.defaultNodeColor;\n  if (!data.label && data.label !== \"\") data.label = null;\n  if (data.label !== undefined && data.label !== null) data.label = \"\" + data.label;else data.label = null;\n  if (!data.size) data.size = 2;\n  if (!hasOwnProperty.call(data, \"hidden\")) data.hidden = false;\n  if (!hasOwnProperty.call(data, \"highlighted\")) data.highlighted = false;\n  if (!hasOwnProperty.call(data, \"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultNodeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\nfunction applyEdgeDefaults(settings, _key, data) {\n  if (!data.color) data.color = settings.defaultEdgeColor;\n  if (!data.label) data.label = \"\";\n  if (!data.size) data.size = 0.5;\n  if (!hasOwnProperty.call(data, \"hidden\")) data.hidden = false;\n  if (!hasOwnProperty.call(data, \"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultEdgeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\n\n/**\n * Main class.\n *\n * @constructor\n * @param {Graph}       graph     - Graph to render.\n * @param {HTMLElement} container - DOM container in which to render.\n * @param {object}      settings  - Optional settings.\n */\nvar Sigma$1 = /*#__PURE__*/function (_TypedEventEmitter) {\n  _inherits(Sigma, _TypedEventEmitter);\n  function Sigma(graph, container) {\n    var _this;\n    var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    _classCallCheck(this, Sigma);\n    _this = _callSuper(this, Sigma);\n\n    // Resolving settings\n    _defineProperty(_assertThisInitialized(_this), \"elements\", {});\n    _defineProperty(_assertThisInitialized(_this), \"canvasContexts\", {});\n    _defineProperty(_assertThisInitialized(_this), \"webGLContexts\", {});\n    _defineProperty(_assertThisInitialized(_this), \"pickingLayers\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"textures\", {});\n    _defineProperty(_assertThisInitialized(_this), \"frameBuffers\", {});\n    _defineProperty(_assertThisInitialized(_this), \"activeListeners\", {});\n    _defineProperty(_assertThisInitialized(_this), \"labelGrid\", new LabelGrid());\n    _defineProperty(_assertThisInitialized(_this), \"nodeDataCache\", {});\n    _defineProperty(_assertThisInitialized(_this), \"edgeDataCache\", {});\n    // Indices to keep track of the index of the item inside programs\n    _defineProperty(_assertThisInitialized(_this), \"nodeProgramIndex\", {});\n    _defineProperty(_assertThisInitialized(_this), \"edgeProgramIndex\", {});\n    _defineProperty(_assertThisInitialized(_this), \"nodesWithForcedLabels\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"edgesWithForcedLabels\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"nodeExtent\", {\n      x: [0, 1],\n      y: [0, 1]\n    });\n    _defineProperty(_assertThisInitialized(_this), \"nodeZExtent\", [Infinity, -Infinity]);\n    _defineProperty(_assertThisInitialized(_this), \"edgeZExtent\", [Infinity, -Infinity]);\n    _defineProperty(_assertThisInitialized(_this), \"matrix\", identity());\n    _defineProperty(_assertThisInitialized(_this), \"invMatrix\", identity());\n    _defineProperty(_assertThisInitialized(_this), \"correctionRatio\", 1);\n    _defineProperty(_assertThisInitialized(_this), \"customBBox\", null);\n    _defineProperty(_assertThisInitialized(_this), \"normalizationFunction\", createNormalizationFunction({\n      x: [0, 1],\n      y: [0, 1]\n    }));\n    // Cache:\n    _defineProperty(_assertThisInitialized(_this), \"graphToViewportRatio\", 1);\n    _defineProperty(_assertThisInitialized(_this), \"itemIDsIndex\", {});\n    _defineProperty(_assertThisInitialized(_this), \"nodeIndices\", {});\n    _defineProperty(_assertThisInitialized(_this), \"edgeIndices\", {});\n    // Starting dimensions and pixel ratio\n    _defineProperty(_assertThisInitialized(_this), \"width\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"height\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"pixelRatio\", getPixelRatio());\n    _defineProperty(_assertThisInitialized(_this), \"pickingDownSizingRatio\", 2 * _this.pixelRatio);\n    // Graph State\n    _defineProperty(_assertThisInitialized(_this), \"displayedNodeLabels\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"displayedEdgeLabels\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"highlightedNodes\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"hoveredNode\", null);\n    _defineProperty(_assertThisInitialized(_this), \"hoveredEdge\", null);\n    // Internal states\n    _defineProperty(_assertThisInitialized(_this), \"renderFrame\", null);\n    _defineProperty(_assertThisInitialized(_this), \"renderHighlightedNodesFrame\", null);\n    _defineProperty(_assertThisInitialized(_this), \"needToProcess\", false);\n    _defineProperty(_assertThisInitialized(_this), \"checkEdgesEventsFrame\", null);\n    // Programs\n    _defineProperty(_assertThisInitialized(_this), \"nodePrograms\", {});\n    _defineProperty(_assertThisInitialized(_this), \"nodeHoverPrograms\", {});\n    _defineProperty(_assertThisInitialized(_this), \"edgePrograms\", {});\n    _this.settings = resolveSettings(settings);\n\n    // Validating\n    validateSettings(_this.settings);\n    validateGraph(graph);\n    if (!(container instanceof HTMLElement)) throw new Error(\"Sigma: container should be an html element.\");\n\n    // Properties\n    _this.graph = graph;\n    _this.container = container;\n\n    // Initializing contexts\n    _this.createWebGLContext(\"edges\", {\n      picking: settings.enableEdgeEvents\n    });\n    _this.createCanvasContext(\"edgeLabels\");\n    _this.createWebGLContext(\"nodes\", {\n      picking: true\n    });\n    _this.createCanvasContext(\"labels\");\n    _this.createCanvasContext(\"hovers\");\n    _this.createWebGLContext(\"hoverNodes\");\n    _this.createCanvasContext(\"mouse\");\n\n    // Initial resize\n    _this.resize();\n\n    // Loading programs\n    for (var type in _this.settings.nodeProgramClasses) {\n      _this.registerNodeProgram(type, _this.settings.nodeProgramClasses[type], _this.settings.nodeHoverProgramClasses[type]);\n    }\n    for (var _type in _this.settings.edgeProgramClasses) {\n      _this.registerEdgeProgram(_type, _this.settings.edgeProgramClasses[_type]);\n    }\n\n    // Initializing the camera\n    _this.camera = new Camera();\n\n    // Binding camera events\n    _this.bindCameraHandlers();\n\n    // Initializing captors\n    _this.mouseCaptor = new MouseCaptor(_this.elements.mouse, _assertThisInitialized(_this));\n    _this.mouseCaptor.setSettings(_this.settings);\n    _this.touchCaptor = new TouchCaptor(_this.elements.mouse, _assertThisInitialized(_this));\n    _this.touchCaptor.setSettings(_this.settings);\n\n    // Binding event handlers\n    _this.bindEventHandlers();\n\n    // Binding graph handlers\n    _this.bindGraphHandlers();\n\n    // Trigger eventual settings-related things\n    _this.handleSettingsUpdate();\n\n    // Processing data for the first time & render\n    _this.refresh();\n    return _this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Internal methods.\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Internal function used to register a node program\n   *\n   * @param  {string}           key              - The program's key, matching the related nodes \"type\" values.\n   * @param  {NodeProgramType}  NodeProgramClass - A nodes program class.\n   * @param  {NodeProgramType?} NodeHoverProgram - A nodes program class to render hovered nodes (optional).\n   * @return {Sigma}\n   */\n  _createClass(Sigma, [{\n    key: \"registerNodeProgram\",\n    value: function registerNodeProgram(key, NodeProgramClass, NodeHoverProgram) {\n      if (this.nodePrograms[key]) this.nodePrograms[key].kill();\n      if (this.nodeHoverPrograms[key]) this.nodeHoverPrograms[key].kill();\n      this.nodePrograms[key] = new NodeProgramClass(this.webGLContexts.nodes, this.frameBuffers.nodes, this);\n      this.nodeHoverPrograms[key] = new (NodeHoverProgram || NodeProgramClass)(this.webGLContexts.hoverNodes, null, this);\n      return this;\n    }\n\n    /**\n     * Internal function used to register an edge program\n     *\n     * @param  {string}          key              - The program's key, matching the related edges \"type\" values.\n     * @param  {EdgeProgramType} EdgeProgramClass - An edges program class.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"registerEdgeProgram\",\n    value: function registerEdgeProgram(key, EdgeProgramClass) {\n      if (this.edgePrograms[key]) this.edgePrograms[key].kill();\n      this.edgePrograms[key] = new EdgeProgramClass(this.webGLContexts.edges, this.frameBuffers.edges, this);\n      return this;\n    }\n\n    /**\n     * Internal function used to unregister a node program\n     *\n     * @param  {string} key - The program's key, matching the related nodes \"type\" values.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"unregisterNodeProgram\",\n    value: function unregisterNodeProgram(key) {\n      if (this.nodePrograms[key]) {\n        var _this$nodePrograms = this.nodePrograms,\n          program = _this$nodePrograms[key],\n          programs = _objectWithoutProperties(_this$nodePrograms, [key].map(toPropertyKey));\n        program.kill();\n        this.nodePrograms = programs;\n      }\n      if (this.nodeHoverPrograms[key]) {\n        var _this$nodeHoverProgra = this.nodeHoverPrograms,\n          _program = _this$nodeHoverProgra[key],\n          _programs = _objectWithoutProperties(_this$nodeHoverProgra, [key].map(toPropertyKey));\n        _program.kill();\n        this.nodePrograms = _programs;\n      }\n      return this;\n    }\n\n    /**\n     * Internal function used to unregister an edge program\n     *\n     * @param  {string} key - The program's key, matching the related edges \"type\" values.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"unregisterEdgeProgram\",\n    value: function unregisterEdgeProgram(key) {\n      if (this.edgePrograms[key]) {\n        var _this$edgePrograms = this.edgePrograms,\n          program = _this$edgePrograms[key],\n          programs = _objectWithoutProperties(_this$edgePrograms, [key].map(toPropertyKey));\n        program.kill();\n        this.edgePrograms = programs;\n      }\n      return this;\n    }\n\n    /**\n     * Method (re)binding WebGL texture (for picking).\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"resetWebGLTexture\",\n    value: function resetWebGLTexture(id) {\n      var gl = this.webGLContexts[id];\n      var frameBuffer = this.frameBuffers[id];\n      var currentTexture = this.textures[id];\n      if (currentTexture) gl.deleteTexture(currentTexture);\n      var pickingTexture = gl.createTexture();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n      gl.bindTexture(gl.TEXTURE_2D, pickingTexture);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, pickingTexture, 0);\n      this.textures[id] = pickingTexture;\n      return this;\n    }\n\n    /**\n     * Method binding camera handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindCameraHandlers\",\n    value: function bindCameraHandlers() {\n      var _this2 = this;\n      this.activeListeners.camera = function () {\n        _this2.scheduleRender();\n      };\n      this.camera.on(\"updated\", this.activeListeners.camera);\n      return this;\n    }\n\n    /**\n     * Method unbinding camera handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"unbindCameraHandlers\",\n    value: function unbindCameraHandlers() {\n      this.camera.removeListener(\"updated\", this.activeListeners.camera);\n      return this;\n    }\n\n    /**\n     * Method that returns the closest node to a given position.\n     */\n  }, {\n    key: \"getNodeAtPosition\",\n    value: function getNodeAtPosition(position) {\n      var x = position.x,\n        y = position.y;\n      var color = getPixelColor(this.webGLContexts.nodes, this.frameBuffers.nodes, x, y, this.pixelRatio, this.pickingDownSizingRatio);\n      var index = colorToIndex.apply(void 0, _toConsumableArray(color));\n      var itemAt = this.itemIDsIndex[index];\n      return itemAt && itemAt.type === \"node\" ? itemAt.id : null;\n    }\n\n    /**\n     * Method binding event handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindEventHandlers\",\n    value: function bindEventHandlers() {\n      var _this3 = this;\n      // Handling window resize\n      this.activeListeners.handleResize = function () {\n        // need to call a refresh to rebuild the labelgrid\n        _this3.scheduleRefresh();\n      };\n      window.addEventListener(\"resize\", this.activeListeners.handleResize);\n\n      // Handling mouse move\n      this.activeListeners.handleMove = function (e) {\n        var baseEvent = {\n          event: e,\n          preventSigmaDefault: function preventSigmaDefault() {\n            e.preventSigmaDefault();\n          }\n        };\n        var nodeToHover = _this3.getNodeAtPosition(e);\n        if (nodeToHover && _this3.hoveredNode !== nodeToHover && !_this3.nodeDataCache[nodeToHover].hidden) {\n          // Handling passing from one node to the other directly\n          if (_this3.hoveredNode) _this3.emit(\"leaveNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: _this3.hoveredNode\n          }));\n          _this3.hoveredNode = nodeToHover;\n          _this3.emit(\"enterNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: nodeToHover\n          }));\n          _this3.scheduleHighlightedNodesRender();\n          return;\n        }\n\n        // Checking if the hovered node is still hovered\n        if (_this3.hoveredNode) {\n          if (_this3.getNodeAtPosition(e) !== _this3.hoveredNode) {\n            var node = _this3.hoveredNode;\n            _this3.hoveredNode = null;\n            _this3.emit(\"leaveNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              node: node\n            }));\n            _this3.scheduleHighlightedNodesRender();\n            return;\n          }\n        }\n        if (_this3.settings.enableEdgeEvents) {\n          var edgeToHover = _this3.hoveredNode ? null : _this3.getEdgeAtPoint(baseEvent.event.x, baseEvent.event.y);\n          if (edgeToHover !== _this3.hoveredEdge) {\n            if (_this3.hoveredEdge) _this3.emit(\"leaveEdge\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              edge: _this3.hoveredEdge\n            }));\n            if (edgeToHover) _this3.emit(\"enterEdge\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              edge: edgeToHover\n            }));\n            _this3.hoveredEdge = edgeToHover;\n          }\n        }\n      };\n\n      // Handling mouse leave stage:\n      this.activeListeners.handleLeave = function (e) {\n        var baseEvent = {\n          event: e,\n          preventSigmaDefault: function preventSigmaDefault() {\n            e.preventSigmaDefault();\n          }\n        };\n        if (_this3.hoveredNode) {\n          _this3.emit(\"leaveNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: _this3.hoveredNode\n          }));\n          _this3.scheduleHighlightedNodesRender();\n        }\n        if (_this3.settings.enableEdgeEvents && _this3.hoveredEdge) {\n          _this3.emit(\"leaveEdge\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            edge: _this3.hoveredEdge\n          }));\n          _this3.scheduleHighlightedNodesRender();\n        }\n        _this3.emit(\"leaveStage\", _objectSpread2({}, baseEvent));\n      };\n\n      // Handling mouse enter stage:\n      this.activeListeners.handleEnter = function (e) {\n        var baseEvent = {\n          event: e,\n          preventSigmaDefault: function preventSigmaDefault() {\n            e.preventSigmaDefault();\n          }\n        };\n        _this3.emit(\"enterStage\", _objectSpread2({}, baseEvent));\n      };\n\n      // Handling click\n      var createMouseListener = function createMouseListener(eventType) {\n        return function (e) {\n          var baseEvent = {\n            event: e,\n            preventSigmaDefault: function preventSigmaDefault() {\n              e.preventSigmaDefault();\n            }\n          };\n          var isFakeSigmaMouseEvent = e.original.isFakeSigmaMouseEvent;\n          var nodeAtPosition = isFakeSigmaMouseEvent ? _this3.getNodeAtPosition(e) : _this3.hoveredNode;\n          if (nodeAtPosition) return _this3.emit(\"\".concat(eventType, \"Node\"), _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: nodeAtPosition\n          }));\n          if (_this3.settings.enableEdgeEvents) {\n            var edge = _this3.getEdgeAtPoint(e.x, e.y);\n            if (edge) return _this3.emit(\"\".concat(eventType, \"Edge\"), _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              edge: edge\n            }));\n          }\n          return _this3.emit(\"\".concat(eventType, \"Stage\"), baseEvent);\n        };\n      };\n      this.activeListeners.handleClick = createMouseListener(\"click\");\n      this.activeListeners.handleRightClick = createMouseListener(\"rightClick\");\n      this.activeListeners.handleDoubleClick = createMouseListener(\"doubleClick\");\n      this.activeListeners.handleWheel = createMouseListener(\"wheel\");\n      this.activeListeners.handleDown = createMouseListener(\"down\");\n      this.activeListeners.handleUp = createMouseListener(\"up\");\n      this.mouseCaptor.on(\"mousemove\", this.activeListeners.handleMove);\n      this.mouseCaptor.on(\"click\", this.activeListeners.handleClick);\n      this.mouseCaptor.on(\"rightClick\", this.activeListeners.handleRightClick);\n      this.mouseCaptor.on(\"doubleClick\", this.activeListeners.handleDoubleClick);\n      this.mouseCaptor.on(\"wheel\", this.activeListeners.handleWheel);\n      this.mouseCaptor.on(\"mousedown\", this.activeListeners.handleDown);\n      this.mouseCaptor.on(\"mouseup\", this.activeListeners.handleUp);\n      this.mouseCaptor.on(\"mouseleave\", this.activeListeners.handleLeave);\n      this.mouseCaptor.on(\"mouseenter\", this.activeListeners.handleEnter);\n\n      // TODO\n      // Deal with Touch captor events\n\n      return this;\n    }\n\n    /**\n     * Method binding graph handlers\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindGraphHandlers\",\n    value: function bindGraphHandlers() {\n      var _this4 = this;\n      var graph = this.graph;\n      var LAYOUT_IMPACTING_FIELDS = new Set([\"x\", \"y\", \"zIndex\", \"type\"]);\n      this.activeListeners.eachNodeAttributesUpdatedGraphUpdate = function (e) {\n        var _e$hints;\n        var updatedFields = (_e$hints = e.hints) === null || _e$hints === void 0 ? void 0 : _e$hints.attributes;\n        // we process all nodes\n        _this4.graph.forEachNode(function (node) {\n          return _this4.updateNode(node);\n        });\n\n        // if coord, type or zIndex have changed, we need to schedule a render\n        // (zIndex for the programIndex)\n        var layoutChanged = !updatedFields || updatedFields.some(function (f) {\n          return LAYOUT_IMPACTING_FIELDS.has(f);\n        });\n        _this4.refresh({\n          partialGraph: {\n            nodes: graph.nodes()\n          },\n          skipIndexation: !layoutChanged,\n          schedule: true\n        });\n      };\n      this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate = function (e) {\n        var _e$hints2;\n        var updatedFields = (_e$hints2 = e.hints) === null || _e$hints2 === void 0 ? void 0 : _e$hints2.attributes;\n        // we process all edges\n        _this4.graph.forEachEdge(function (edge) {\n          return _this4.updateEdge(edge);\n        });\n        var layoutChanged = updatedFields && [\"zIndex\", \"type\"].some(function (f) {\n          return updatedFields === null || updatedFields === void 0 ? void 0 : updatedFields.includes(f);\n        });\n        _this4.refresh({\n          partialGraph: {\n            edges: graph.edges()\n          },\n          skipIndexation: !layoutChanged,\n          schedule: true\n        });\n      };\n\n      // On add node, we add the node in indices and then call for a render\n      this.activeListeners.addNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // we process the node\n        _this4.addNode(node);\n        // schedule a render for the node\n        _this4.refresh({\n          partialGraph: {\n            nodes: [node]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On update node, we update indices and then call for a render\n      this.activeListeners.updateNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // schedule a render for the node\n        _this4.refresh({\n          partialGraph: {\n            nodes: [node]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On drop node, we remove the node from indices and then call for a refresh\n      this.activeListeners.dropNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // we process the node\n        _this4.removeNode(node);\n        // schedule a render for everything\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On add edge, we remove the edge from indices and then call for a refresh\n      this.activeListeners.addEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // we process the edge\n        _this4.addEdge(edge);\n        // schedule a render for the edge\n        _this4.refresh({\n          partialGraph: {\n            edges: [edge]\n          },\n          schedule: true\n        });\n      };\n\n      // On update edge, we update indices and then call for a refresh\n      this.activeListeners.updateEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // schedule a repaint for the edge\n        _this4.refresh({\n          partialGraph: {\n            edges: [edge]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On drop edge, we remove the edge from indices and then call for a refresh\n      this.activeListeners.dropEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // we process the edge\n        _this4.removeEdge(edge);\n        // schedule a render for all edges\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On clear edges, we clear the edge indices and then call for a refresh\n      this.activeListeners.clearEdgesGraphUpdate = function () {\n        // we clear the edge data structures\n        _this4.clearEdgeState();\n        _this4.clearEdgeIndices();\n        // schedule a render for all edges\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On graph clear, we clear indices and then call for a refresh\n      this.activeListeners.clearGraphUpdate = function () {\n        // clear graph state\n        _this4.clearEdgeState();\n        _this4.clearNodeState();\n\n        // clear graph indices\n        _this4.clearEdgeIndices();\n        _this4.clearNodeIndices();\n\n        // schedule a render for all\n        _this4.refresh({\n          schedule: true\n        });\n      };\n      graph.on(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n      graph.on(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n      graph.on(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n      graph.on(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n      graph.on(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n      graph.on(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n      graph.on(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n      graph.on(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n      graph.on(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n      graph.on(\"cleared\", this.activeListeners.clearGraphUpdate);\n      return this;\n    }\n\n    /**\n     * Method used to unbind handlers from the graph.\n     *\n     * @return {undefined}\n     */\n  }, {\n    key: \"unbindGraphHandlers\",\n    value: function unbindGraphHandlers() {\n      var graph = this.graph;\n      graph.removeListener(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n      graph.removeListener(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n      graph.removeListener(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n      graph.removeListener(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n      graph.removeListener(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n      graph.removeListener(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n      graph.removeListener(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n      graph.removeListener(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n      graph.removeListener(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n      graph.removeListener(\"cleared\", this.activeListeners.clearGraphUpdate);\n    }\n\n    /**\n     * Method looking for an edge colliding with a given point at (x, y). Returns\n     * the key of the edge if any, or null else.\n     */\n  }, {\n    key: \"getEdgeAtPoint\",\n    value: function getEdgeAtPoint(x, y) {\n      var color = getPixelColor(this.webGLContexts.edges, this.frameBuffers.edges, x, y, this.pixelRatio, this.pickingDownSizingRatio);\n      var index = colorToIndex.apply(void 0, _toConsumableArray(color));\n      var itemAt = this.itemIDsIndex[index];\n      return itemAt && itemAt.type === \"edge\" ? itemAt.id : null;\n    }\n\n    /**\n     * Method used to process the whole graph's data.\n     *  - extent\n     *  - normalizationFunction\n     *  - compute node's coordinate\n     *  - labelgrid\n     *  - program data allocation\n     * @return {Sigma}\n     */\n  }, {\n    key: \"process\",\n    value: function process() {\n      var _this5 = this;\n      this.emit(\"beforeProcess\");\n      var graph = this.graph;\n      var settings = this.settings;\n      var dimensions = this.getDimensions();\n\n      //\n      // NODES\n      //\n      this.nodeExtent = graphExtent(this.graph);\n      if (!this.settings.autoRescale) {\n        var width = dimensions.width,\n          height = dimensions.height;\n        var _this$nodeExtent = this.nodeExtent,\n          x = _this$nodeExtent.x,\n          y = _this$nodeExtent.y;\n        this.nodeExtent = {\n          x: [(x[0] + x[1]) / 2 - width / 2, (x[0] + x[1]) / 2 + width / 2],\n          y: [(y[0] + y[1]) / 2 - height / 2, (y[0] + y[1]) / 2 + height / 2]\n        };\n      }\n      this.normalizationFunction = createNormalizationFunction(this.customBBox || this.nodeExtent);\n\n      // NOTE: it is important to compute this matrix after computing the node's extent\n      // because #.getGraphDimensions relies on it\n      var nullCamera = new Camera();\n      var nullCameraMatrix = matrixFromCamera(nullCamera.getState(), dimensions, this.getGraphDimensions(), this.getStagePadding());\n      // Resetting the label grid\n      // TODO: it's probably better to do this explicitly or on resizes for layout and anims\n      this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);\n      var nodesPerPrograms = {};\n      var nodeIndices = {};\n      var edgeIndices = {};\n      var itemIDsIndex = {};\n      var incrID = 1;\n      var nodes = graph.nodes();\n\n      // Do some indexation on the whole graph\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        var node = nodes[i];\n        var data = this.nodeDataCache[node];\n\n        // Get initial coordinates\n        var attrs = graph.getNodeAttributes(node);\n        data.x = attrs.x;\n        data.y = attrs.y;\n        this.normalizationFunction.applyTo(data);\n\n        // labelgrid\n        if (typeof data.label === \"string\" && !data.hidden) this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, {\n          matrix: nullCameraMatrix\n        }));\n\n        // update count per program\n        nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;\n      }\n      this.labelGrid.organize();\n\n      // Allocate memory to programs\n      for (var type in this.nodePrograms) {\n        if (!hasOwnProperty.call(this.nodePrograms, type)) {\n          throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(type, \"\\\"!\"));\n        }\n        this.nodePrograms[type].reallocate(nodesPerPrograms[type] || 0);\n        // We reset that count here, so that we can reuse it while calling the Program#process methods:\n        nodesPerPrograms[type] = 0;\n      }\n\n      // Order nodes by zIndex before to add them to program\n      if (this.settings.zIndex && this.nodeZExtent[0] !== this.nodeZExtent[1]) nodes = zIndexOrdering(this.nodeZExtent, function (node) {\n        return _this5.nodeDataCache[node].zIndex;\n      }, nodes);\n\n      // Add data to programs\n      for (var _i = 0, _l = nodes.length; _i < _l; _i++) {\n        var _node = nodes[_i];\n        nodeIndices[_node] = incrID;\n        itemIDsIndex[nodeIndices[_node]] = {\n          type: \"node\",\n          id: _node\n        };\n        incrID++;\n        var _data = this.nodeDataCache[_node];\n        this.addNodeToProgram(_node, nodeIndices[_node], nodesPerPrograms[_data.type]++);\n      }\n\n      //\n      // EDGES\n      //\n\n      var edgesPerPrograms = {};\n      var edges = graph.edges();\n\n      // Allocate memory to programs\n      for (var _i2 = 0, _l2 = edges.length; _i2 < _l2; _i2++) {\n        var edge = edges[_i2];\n        var _data2 = this.edgeDataCache[edge];\n        edgesPerPrograms[_data2.type] = (edgesPerPrograms[_data2.type] || 0) + 1;\n      }\n\n      // Order edges by zIndex before to add them to program\n      if (this.settings.zIndex && this.edgeZExtent[0] !== this.edgeZExtent[1]) edges = zIndexOrdering(this.edgeZExtent, function (edge) {\n        return _this5.edgeDataCache[edge].zIndex;\n      }, edges);\n      for (var _type2 in this.edgePrograms) {\n        if (!hasOwnProperty.call(this.edgePrograms, _type2)) {\n          throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(_type2, \"\\\"!\"));\n        }\n        this.edgePrograms[_type2].reallocate(edgesPerPrograms[_type2] || 0);\n        // We reset that count here, so that we can reuse it while calling the Program#process methods:\n        edgesPerPrograms[_type2] = 0;\n      }\n\n      // Add data to programs\n      for (var _i3 = 0, _l3 = edges.length; _i3 < _l3; _i3++) {\n        var _edge = edges[_i3];\n        edgeIndices[_edge] = incrID;\n        itemIDsIndex[edgeIndices[_edge]] = {\n          type: \"edge\",\n          id: _edge\n        };\n        incrID++;\n        var _data3 = this.edgeDataCache[_edge];\n        this.addEdgeToProgram(_edge, edgeIndices[_edge], edgesPerPrograms[_data3.type]++);\n      }\n      this.itemIDsIndex = itemIDsIndex;\n      this.nodeIndices = nodeIndices;\n      this.edgeIndices = edgeIndices;\n      this.emit(\"afterProcess\");\n      return this;\n    }\n\n    /**\n     * Method that backports potential settings updates where it's needed.\n     * @private\n     */\n  }, {\n    key: \"handleSettingsUpdate\",\n    value: function handleSettingsUpdate(oldSettings) {\n      var settings = this.settings;\n      this.camera.minRatio = settings.minCameraRatio;\n      this.camera.maxRatio = settings.maxCameraRatio;\n      this.camera.enabledRotation = settings.enableCameraRotation;\n      this.camera.setState(this.camera.validateState(this.camera.getState()));\n      if (oldSettings) {\n        // Check edge programs:\n        if (oldSettings.edgeProgramClasses !== settings.edgeProgramClasses) {\n          for (var type in settings.edgeProgramClasses) {\n            if (settings.edgeProgramClasses[type] !== oldSettings.edgeProgramClasses[type]) {\n              this.registerEdgeProgram(type, settings.edgeProgramClasses[type]);\n            }\n          }\n          for (var _type3 in oldSettings.edgeProgramClasses) {\n            if (!settings.edgeProgramClasses[_type3]) this.unregisterEdgeProgram(_type3);\n          }\n        }\n\n        // Check node programs:\n        if (oldSettings.nodeProgramClasses !== settings.nodeProgramClasses || oldSettings.nodeHoverProgramClasses !== settings.nodeHoverProgramClasses) {\n          for (var _type4 in settings.nodeProgramClasses) {\n            if (settings.nodeProgramClasses[_type4] !== oldSettings.nodeProgramClasses[_type4] || settings.nodeHoverProgramClasses[_type4] !== oldSettings.nodeHoverProgramClasses[_type4]) {\n              this.registerNodeProgram(_type4, settings.nodeProgramClasses[_type4], settings.nodeHoverProgramClasses[_type4]);\n            }\n          }\n          for (var _type5 in oldSettings.nodeProgramClasses) {\n            if (!settings.nodeProgramClasses[_type5]) this.unregisterNodeProgram(_type5);\n          }\n        }\n      }\n\n      // Update captors settings:\n      this.mouseCaptor.setSettings(this.settings);\n      this.touchCaptor.setSettings(this.settings);\n      return this;\n    }\n\n    /**\n     * Method used to render labels.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderLabels\",\n    value: function renderLabels() {\n      if (!this.settings.renderLabels) return this;\n      var cameraState = this.camera.getState();\n\n      // Selecting labels to draw\n      var labelsToDisplay = this.labelGrid.getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity);\n      extend(labelsToDisplay, this.nodesWithForcedLabels);\n      this.displayedNodeLabels = new Set();\n\n      // Drawing labels\n      var context = this.canvasContexts.labels;\n      for (var i = 0, l = labelsToDisplay.length; i < l; i++) {\n        var node = labelsToDisplay[i];\n        var data = this.nodeDataCache[node];\n\n        // If the node was already drawn (like if it is eligible AND has\n        // `forceLabel`), we don't want to draw it again\n        // NOTE: we can do better probably\n        if (this.displayedNodeLabels.has(node)) continue;\n\n        // If the node is hidden, we don't need to display its label obviously\n        if (data.hidden) continue;\n        var _this$framedGraphToVi = this.framedGraphToViewport(data),\n          x = _this$framedGraphToVi.x,\n          y = _this$framedGraphToVi.y;\n\n        // NOTE: we can cache the labels we need to render until the camera's ratio changes\n        var size = this.scaleSize(data.size);\n\n        // Is node big enough?\n        if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold) continue;\n\n        // Is node actually on screen (with some margin)\n        // NOTE: we used to rely on the quadtree for this, but the coordinates\n        // conversion make it unreliable and at that point we already converted\n        // to viewport coordinates and since the label grid already culls the\n        // number of potential labels to display this looks like a good\n        // performance compromise.\n        // NOTE: labelGrid.getLabelsToDisplay could probably optimize by not\n        // considering cells obviously outside of the range of the current\n        // view rectangle.\n        if (x < -X_LABEL_MARGIN || x > this.width + X_LABEL_MARGIN || y < -Y_LABEL_MARGIN || y > this.height + Y_LABEL_MARGIN) continue;\n\n        // Because displayed edge labels depend directly on actually rendered node\n        // labels, we need to only add to this.displayedNodeLabels nodes whose label\n        // is rendered.\n        // This makes this.displayedNodeLabels depend on viewport, which might become\n        // an issue once we start memoizing getLabelsToDisplay.\n        this.displayedNodeLabels.add(node);\n        var defaultDrawNodeLabel = this.settings.defaultDrawNodeLabel;\n        var nodeProgram = this.nodePrograms[data.type];\n        var drawLabel = (nodeProgram === null || nodeProgram === void 0 ? void 0 : nodeProgram.drawLabel) || defaultDrawNodeLabel;\n        drawLabel(context, _objectSpread2(_objectSpread2({\n          key: node\n        }, data), {}, {\n          size: size,\n          x: x,\n          y: y\n        }), this.settings);\n      }\n      return this;\n    }\n\n    /**\n     * Method used to render edge labels, based on which node labels were\n     * rendered.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderEdgeLabels\",\n    value: function renderEdgeLabels() {\n      if (!this.settings.renderEdgeLabels) return this;\n      var context = this.canvasContexts.edgeLabels;\n\n      // Clearing\n      context.clearRect(0, 0, this.width, this.height);\n      var edgeLabelsToDisplay = edgeLabelsToDisplayFromNodes({\n        graph: this.graph,\n        hoveredNode: this.hoveredNode,\n        displayedNodeLabels: this.displayedNodeLabels,\n        highlightedNodes: this.highlightedNodes\n      });\n      extend(edgeLabelsToDisplay, this.edgesWithForcedLabels);\n      var displayedLabels = new Set();\n      for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {\n        var edge = edgeLabelsToDisplay[i],\n          extremities = this.graph.extremities(edge),\n          sourceData = this.nodeDataCache[extremities[0]],\n          targetData = this.nodeDataCache[extremities[1]],\n          edgeData = this.edgeDataCache[edge];\n\n        // If the edge was already drawn (like if it is eligible AND has\n        // `forceLabel`), we don't want to draw it again\n        if (displayedLabels.has(edge)) continue;\n\n        // If the edge is hidden we don't need to display its label\n        // NOTE: the test on sourceData & targetData is probably paranoid at this point?\n        if (edgeData.hidden || sourceData.hidden || targetData.hidden) {\n          continue;\n        }\n        var defaultDrawEdgeLabel = this.settings.defaultDrawEdgeLabel;\n        var edgeProgram = this.edgePrograms[edgeData.type];\n        var drawLabel = (edgeProgram === null || edgeProgram === void 0 ? void 0 : edgeProgram.drawLabel) || defaultDrawEdgeLabel;\n        drawLabel(context, _objectSpread2(_objectSpread2({\n          key: edge\n        }, edgeData), {}, {\n          size: this.scaleSize(edgeData.size)\n        }), _objectSpread2(_objectSpread2(_objectSpread2({\n          key: extremities[0]\n        }, sourceData), this.framedGraphToViewport(sourceData)), {}, {\n          size: this.scaleSize(sourceData.size)\n        }), _objectSpread2(_objectSpread2(_objectSpread2({\n          key: extremities[1]\n        }, targetData), this.framedGraphToViewport(targetData)), {}, {\n          size: this.scaleSize(targetData.size)\n        }), this.settings);\n        displayedLabels.add(edge);\n      }\n      this.displayedEdgeLabels = displayedLabels;\n      return this;\n    }\n\n    /**\n     * Method used to render the highlighted nodes.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderHighlightedNodes\",\n    value: function renderHighlightedNodes() {\n      var _this6 = this;\n      var context = this.canvasContexts.hovers;\n\n      // Clearing\n      context.clearRect(0, 0, this.width, this.height);\n\n      // Rendering\n      var render = function render(node) {\n        var data = _this6.nodeDataCache[node];\n        var _this6$framedGraphToV = _this6.framedGraphToViewport(data),\n          x = _this6$framedGraphToV.x,\n          y = _this6$framedGraphToV.y;\n        var size = _this6.scaleSize(data.size);\n        var defaultDrawNodeHover = _this6.settings.defaultDrawNodeHover;\n        var nodeProgram = _this6.nodePrograms[data.type];\n        var drawHover = (nodeProgram === null || nodeProgram === void 0 ? void 0 : nodeProgram.drawHover) || defaultDrawNodeHover;\n        drawHover(context, _objectSpread2(_objectSpread2({\n          key: node\n        }, data), {}, {\n          size: size,\n          x: x,\n          y: y\n        }), _this6.settings);\n      };\n      var nodesToRender = [];\n      if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {\n        nodesToRender.push(this.hoveredNode);\n      }\n      this.highlightedNodes.forEach(function (node) {\n        // The hovered node has already been highlighted\n        if (node !== _this6.hoveredNode) nodesToRender.push(node);\n      });\n\n      // Draw labels:\n      nodesToRender.forEach(function (node) {\n        return render(node);\n      });\n\n      // Draw WebGL nodes on top of the labels:\n      var nodesPerPrograms = {};\n\n      // 1. Count nodes per type:\n      nodesToRender.forEach(function (node) {\n        var type = _this6.nodeDataCache[node].type;\n        nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;\n      });\n      // 2. Allocate for each type for the proper number of nodes\n      for (var type in this.nodeHoverPrograms) {\n        this.nodeHoverPrograms[type].reallocate(nodesPerPrograms[type] || 0);\n        // Also reset count, to use when rendering:\n        nodesPerPrograms[type] = 0;\n      }\n      // 3. Process all nodes to render:\n      nodesToRender.forEach(function (node) {\n        var data = _this6.nodeDataCache[node];\n        _this6.nodeHoverPrograms[data.type].process(0, nodesPerPrograms[data.type]++, data);\n      });\n      // 4. Clear hovered nodes layer:\n      this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n      // 5. Render:\n      var renderParams = this.getRenderParams();\n      for (var _type6 in this.nodeHoverPrograms) {\n        var program = this.nodeHoverPrograms[_type6];\n        program.render(renderParams);\n      }\n    }\n\n    /**\n     * Method used to schedule a hover render.\n     *\n     */\n  }, {\n    key: \"scheduleHighlightedNodesRender\",\n    value: function scheduleHighlightedNodesRender() {\n      var _this7 = this;\n      if (this.renderHighlightedNodesFrame || this.renderFrame) return;\n      this.renderHighlightedNodesFrame = requestAnimationFrame(function () {\n        // Resetting state\n        _this7.renderHighlightedNodesFrame = null;\n\n        // Rendering\n        _this7.renderHighlightedNodes();\n        _this7.renderEdgeLabels();\n      });\n    }\n\n    /**\n     * Method used to render.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this8 = this;\n      this.emit(\"beforeRender\");\n      var exitRender = function exitRender() {\n        _this8.emit(\"afterRender\");\n        return _this8;\n      };\n\n      // If a render was scheduled, we cancel it\n      if (this.renderFrame) {\n        cancelAnimationFrame(this.renderFrame);\n        this.renderFrame = null;\n      }\n\n      // First we need to resize\n      this.resize();\n\n      // Do we need to reprocess data?\n      if (this.needToProcess) this.process();\n      this.needToProcess = false;\n\n      // Clearing the canvases\n      this.clear();\n\n      // Prepare the textures\n      this.pickingLayers.forEach(function (layer) {\n        return _this8.resetWebGLTexture(layer);\n      });\n\n      // If we have no nodes we can stop right there\n      if (!this.graph.order) return exitRender();\n\n      // TODO: improve this heuristic or move to the captor itself?\n      // TODO: deal with the touch captor here as well\n      var mouseCaptor = this.mouseCaptor;\n      var moving = this.camera.isAnimated() || mouseCaptor.isMoving || mouseCaptor.draggedEvents || mouseCaptor.currentWheelDirection;\n\n      // Then we need to extract a matrix from the camera\n      var cameraState = this.camera.getState();\n      var viewportDimensions = this.getDimensions();\n      var graphDimensions = this.getGraphDimensions();\n      var padding = this.getStagePadding();\n      this.matrix = matrixFromCamera(cameraState, viewportDimensions, graphDimensions, padding);\n      this.invMatrix = matrixFromCamera(cameraState, viewportDimensions, graphDimensions, padding, true);\n      this.correctionRatio = getMatrixImpact(this.matrix, cameraState, viewportDimensions);\n      this.graphToViewportRatio = this.getGraphToViewportRatio();\n\n      // [jacomyal]\n      // This comment is related to the one above the `getMatrixImpact` definition:\n      // - `this.correctionRatio` is somehow not completely explained\n      // - `this.graphToViewportRatio` is the ratio of a distance in the viewport divided by the same distance in the\n      //   graph\n      // - `this.normalizationFunction.ratio` is basically `Math.max(graphDX, graphDY)`\n      // And now, I observe that if I multiply these three ratios, I have something constant, which value remains 2, even\n      // when I change the graph, the viewport or the camera. It might be useful later, so I prefer to let this comment:\n      // console.log(this.graphToViewportRatio * this.correctionRatio * this.normalizationFunction.ratio * 2);\n\n      var params = this.getRenderParams();\n\n      // Drawing nodes\n      for (var type in this.nodePrograms) {\n        var program = this.nodePrograms[type];\n        program.render(params);\n      }\n\n      // Drawing edges\n      if (!this.settings.hideEdgesOnMove || !moving) {\n        for (var _type7 in this.edgePrograms) {\n          var _program2 = this.edgePrograms[_type7];\n          _program2.render(params);\n        }\n      }\n\n      // Do not display labels on move per setting\n      if (this.settings.hideLabelsOnMove && moving) return exitRender();\n      this.renderLabels();\n      this.renderEdgeLabels();\n      this.renderHighlightedNodes();\n      return exitRender();\n    }\n\n    /**\n     * Add a node in the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"addNode\",\n    value: function addNode(key) {\n      // Node display data resolution:\n      //  1. First we get the node's attributes\n      //  2. We optionally reduce them using the function provided by the user\n      //     Note that this function must return a total object and won't be merged\n      //  3. We apply our defaults, while running some vital checks\n      //  4. We apply the normalization function\n      // We shallow copy node data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, this.graph.getNodeAttributes(key));\n      if (this.settings.nodeReducer) attr = this.settings.nodeReducer(key, attr);\n      var data = applyNodeDefaults(this.settings, key, attr);\n      this.nodeDataCache[key] = data;\n\n      // Label:\n      // We delete and add if needed because this function is also used from\n      // update\n      this.nodesWithForcedLabels[\"delete\"](key);\n      if (data.forceLabel && !data.hidden) this.nodesWithForcedLabels.add(key);\n\n      // Highlighted:\n      // We remove and re add if needed because this function is also used from\n      // update\n      this.highlightedNodes[\"delete\"](key);\n      if (data.highlighted && !data.hidden) this.highlightedNodes.add(key);\n\n      // zIndex\n      if (this.settings.zIndex) {\n        if (data.zIndex < this.nodeZExtent[0]) this.nodeZExtent[0] = data.zIndex;\n        if (data.zIndex > this.nodeZExtent[1]) this.nodeZExtent[1] = data.zIndex;\n      }\n    }\n\n    /**\n     * Update a node the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"updateNode\",\n    value: function updateNode(key) {\n      this.addNode(key);\n\n      // Re-apply normalization on the node\n      var data = this.nodeDataCache[key];\n      this.normalizationFunction.applyTo(data);\n    }\n\n    /**\n     * Remove a node from the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"removeNode\",\n    value: function removeNode(key) {\n      // Remove from node cache\n      delete this.nodeDataCache[key];\n      // Remove from node program index\n      delete this.nodeProgramIndex[key];\n      // Remove from higlighted nodes\n      this.highlightedNodes[\"delete\"](key);\n      // Remove from hovered\n      if (this.hoveredNode === key) this.hoveredNode = null;\n      // Remove from forced label\n      this.nodesWithForcedLabels[\"delete\"](key);\n    }\n\n    /**\n     * Add an edge into the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"addEdge\",\n    value: function addEdge(key) {\n      // Edge display data resolution:\n      //  1. First we get the edge's attributes\n      //  2. We optionally reduce them using the function provided by the user\n      //  3. Note that this function must return a total object and won't be merged\n      //  4. We apply our defaults, while running some vital checks\n      // We shallow copy edge data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, this.graph.getEdgeAttributes(key));\n      if (this.settings.edgeReducer) attr = this.settings.edgeReducer(key, attr);\n      var data = applyEdgeDefaults(this.settings, key, attr);\n      this.edgeDataCache[key] = data;\n\n      // Forced label\n      // we filter and re push if needed because this function is also used from\n      // update\n      this.edgesWithForcedLabels[\"delete\"](key);\n      if (data.forceLabel && !data.hidden) this.edgesWithForcedLabels.add(key);\n\n      // Check zIndex\n      if (this.settings.zIndex) {\n        if (data.zIndex < this.edgeZExtent[0]) this.edgeZExtent[0] = data.zIndex;\n        if (data.zIndex > this.edgeZExtent[1]) this.edgeZExtent[1] = data.zIndex;\n      }\n    }\n\n    /**\n     * Update an edge in the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"updateEdge\",\n    value: function updateEdge(key) {\n      this.addEdge(key);\n    }\n\n    /**\n     * Remove an edge from the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"removeEdge\",\n    value: function removeEdge(key) {\n      // Remove from edge cache\n      delete this.edgeDataCache[key];\n      // Remove from programId index\n      delete this.edgeProgramIndex[key];\n      // Remove from hovered\n      if (this.hoveredEdge === key) this.hoveredEdge = null;\n      // Remove from forced label\n      this.edgesWithForcedLabels[\"delete\"](key);\n    }\n\n    /**\n     * Clear all indices related to nodes.\n     * @private\n     */\n  }, {\n    key: \"clearNodeIndices\",\n    value: function clearNodeIndices() {\n      // LabelGrid & nodeExtent are only manage/populated in the process function\n      this.labelGrid = new LabelGrid();\n      this.nodeExtent = {\n        x: [0, 1],\n        y: [0, 1]\n      };\n      this.nodeDataCache = {};\n      this.edgeProgramIndex = {};\n      this.nodesWithForcedLabels = new Set();\n      this.nodeZExtent = [Infinity, -Infinity];\n    }\n\n    /**\n     * Clear all indices related to edges.\n     * @private\n     */\n  }, {\n    key: \"clearEdgeIndices\",\n    value: function clearEdgeIndices() {\n      this.edgeDataCache = {};\n      this.edgeProgramIndex = {};\n      this.edgesWithForcedLabels = new Set();\n      this.edgeZExtent = [Infinity, -Infinity];\n    }\n\n    /**\n     * Clear all indices.\n     * @private\n     */\n  }, {\n    key: \"clearIndices\",\n    value: function clearIndices() {\n      this.clearEdgeIndices();\n      this.clearNodeIndices();\n    }\n\n    /**\n     * Clear all graph state related to nodes.\n     * @private\n     */\n  }, {\n    key: \"clearNodeState\",\n    value: function clearNodeState() {\n      this.displayedNodeLabels = new Set();\n      this.highlightedNodes = new Set();\n      this.hoveredNode = null;\n    }\n\n    /**\n     * Clear all graph state related to edges.\n     * @private\n     */\n  }, {\n    key: \"clearEdgeState\",\n    value: function clearEdgeState() {\n      this.displayedEdgeLabels = new Set();\n      this.highlightedNodes = new Set();\n      this.hoveredEdge = null;\n    }\n\n    /**\n     * Clear all graph state.\n     * @private\n     */\n  }, {\n    key: \"clearState\",\n    value: function clearState() {\n      this.clearEdgeState();\n      this.clearNodeState();\n    }\n\n    /**\n     * Add the node data to its program.\n     * @private\n     * @param node The node's graphology ID\n     * @param fingerprint A fingerprint used to identity the node with picking\n     * @param position The index where to place the node in the program\n     */\n  }, {\n    key: \"addNodeToProgram\",\n    value: function addNodeToProgram(node, fingerprint, position) {\n      var data = this.nodeDataCache[node];\n      var nodeProgram = this.nodePrograms[data.type];\n      if (!nodeProgram) throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(data.type, \"\\\"!\"));\n      nodeProgram.process(fingerprint, position, data);\n      // Saving program index\n      this.nodeProgramIndex[node] = position;\n    }\n\n    /**\n     * Add the edge data to its program.\n     * @private\n     * @param edge The edge's graphology ID\n     * @param fingerprint A fingerprint used to identity the edge with picking\n     * @param position The index where to place the edge in the program\n     */\n  }, {\n    key: \"addEdgeToProgram\",\n    value: function addEdgeToProgram(edge, fingerprint, position) {\n      var data = this.edgeDataCache[edge];\n      var edgeProgram = this.edgePrograms[data.type];\n      if (!edgeProgram) throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(data.type, \"\\\"!\"));\n      var extremities = this.graph.extremities(edge),\n        sourceData = this.nodeDataCache[extremities[0]],\n        targetData = this.nodeDataCache[extremities[1]];\n      edgeProgram.process(fingerprint, position, sourceData, targetData, data);\n      // Saving program index\n      this.edgeProgramIndex[edge] = position;\n    }\n\n    /**---------------------------------------------------------------------------\n     * Public API.\n     **---------------------------------------------------------------------------\n     */\n\n    /**\n     * Function used to get the render params.\n     *\n     * @return {RenderParams}\n     */\n  }, {\n    key: \"getRenderParams\",\n    value: function getRenderParams() {\n      return {\n        matrix: this.matrix,\n        invMatrix: this.invMatrix,\n        width: this.width,\n        height: this.height,\n        pixelRatio: this.pixelRatio,\n        zoomRatio: this.camera.ratio,\n        cameraAngle: this.camera.angle,\n        sizeRatio: 1 / this.scaleSize(),\n        correctionRatio: this.correctionRatio,\n        downSizingRatio: this.pickingDownSizingRatio,\n        minEdgeThickness: this.settings.minEdgeThickness,\n        antiAliasingFeather: this.settings.antiAliasingFeather\n      };\n    }\n\n    /**\n     * Function used to retrieve the actual stage padding value.\n     *\n     * @return {number}\n     */\n  }, {\n    key: \"getStagePadding\",\n    value: function getStagePadding() {\n      var _this$settings = this.settings,\n        stagePadding = _this$settings.stagePadding,\n        autoRescale = _this$settings.autoRescale;\n      return autoRescale ? stagePadding || 0 : 0;\n    }\n\n    /**\n     * Function used to create a canvas element.\n     *\n     * @param {string} id - Context's id.\n     * @param options\n     * @return {Sigma}\n     */\n  }, {\n    key: \"createCanvas\",\n    value: function createCanvas(id) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (this.elements[id]) throw new Error(\"Sigma: a layer named \\\"\".concat(id, \"\\\" already exists\"));\n      var canvas = createElement(\"canvas\", {\n        position: \"absolute\"\n      }, {\n        \"class\": \"sigma-\".concat(id)\n      });\n      this.elements[id] = canvas;\n      if (\"beforeLayer\" in options && options.beforeLayer) {\n        this.elements[options.beforeLayer].before(canvas);\n      } else if (\"afterLayer\" in options && options.afterLayer) {\n        this.elements[options.afterLayer].after(canvas);\n      } else {\n        this.container.appendChild(canvas);\n      }\n      return canvas;\n    }\n\n    /**\n     * Function used to create a canvas context and add the relevant DOM elements.\n     *\n     * @param  {string} id - Context's id.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"createCanvasContext\",\n    value: function createCanvasContext(id) {\n      var canvas = this.createCanvas(id);\n      var contextOptions = {\n        preserveDrawingBuffer: false,\n        antialias: false\n      };\n      this.canvasContexts[id] = canvas.getContext(\"2d\", contextOptions);\n      return this;\n    }\n\n    /**\n     * Function used to create a WebGL context and add the relevant DOM\n     * elements.\n     *\n     * @param  {string}  id      - Context's id.\n     * @param  {object?} options - #getContext params to override (optional)\n     * @return {WebGLRenderingContext}\n     */\n  }, {\n    key: \"createWebGLContext\",\n    value: function createWebGLContext(id, options) {\n      var canvas = (options === null || options === void 0 ? void 0 : options.canvas) || this.createCanvas(id);\n      if (options !== null && options !== void 0 && options.hidden) canvas.remove();\n      var contextOptions = _objectSpread2({\n        preserveDrawingBuffer: false,\n        antialias: false\n      }, options || {});\n      var context;\n\n      // First we try webgl2 for an easy performance boost\n      context = canvas.getContext(\"webgl2\", contextOptions);\n\n      // Else we fall back to webgl\n      if (!context) context = canvas.getContext(\"webgl\", contextOptions);\n\n      // Edge, I am looking right at you...\n      if (!context) context = canvas.getContext(\"experimental-webgl\", contextOptions);\n      var gl = context;\n      this.webGLContexts[id] = gl;\n\n      // Blending:\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n      // Prepare frame buffer for picking layers:\n      if (options !== null && options !== void 0 && options.picking) {\n        this.pickingLayers.add(id);\n        var newFrameBuffer = gl.createFramebuffer();\n        if (!newFrameBuffer) throw new Error(\"Sigma: cannot create a new frame buffer for layer \".concat(id));\n        this.frameBuffers[id] = newFrameBuffer;\n      }\n      return gl;\n    }\n\n    /**\n     * Function used to properly kill a canvas layer.\n     *\n     * @param  {string} id - Layer id.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"killLayer\",\n    value: function killLayer(id) {\n      var canvas = this.elements[id];\n      if (!canvas) throw new Error(\"Sigma: cannot kill layer \".concat(id, \", which does not exist\"));\n      if (this.webGLContexts[id]) {\n        var _gl$getExtension;\n        var gl = this.webGLContexts[id];\n        (_gl$getExtension = gl.getExtension(\"WEBGL_lose_context\")) === null || _gl$getExtension === void 0 || _gl$getExtension.loseContext();\n        delete this.webGLContexts[id];\n      } else {\n        delete this.canvasContexts[id];\n      }\n\n      // Delete canvas:\n      canvas.remove();\n      delete this.elements[id];\n      return this;\n    }\n\n    /**\n     * Method returning the renderer's camera.\n     *\n     * @return {Camera}\n     */\n  }, {\n    key: \"getCamera\",\n    value: function getCamera() {\n      return this.camera;\n    }\n\n    /**\n     * Method setting the renderer's camera.\n     *\n     * @param  {Camera} camera - New camera.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setCamera\",\n    value: function setCamera(camera) {\n      this.unbindCameraHandlers();\n      this.camera = camera;\n      this.bindCameraHandlers();\n    }\n\n    /**\n     * Method returning the container DOM element.\n     *\n     * @return {HTMLElement}\n     */\n  }, {\n    key: \"getContainer\",\n    value: function getContainer() {\n      return this.container;\n    }\n\n    /**\n     * Method returning the renderer's graph.\n     *\n     * @return {Graph}\n     */\n  }, {\n    key: \"getGraph\",\n    value: function getGraph() {\n      return this.graph;\n    }\n\n    /**\n     * Method used to set the renderer's graph.\n     *\n     * @return {Graph}\n     */\n  }, {\n    key: \"setGraph\",\n    value: function setGraph(graph) {\n      if (graph === this.graph) return;\n\n      // Unbinding handlers on the current graph\n      this.unbindGraphHandlers();\n      if (this.checkEdgesEventsFrame !== null) {\n        cancelAnimationFrame(this.checkEdgesEventsFrame);\n        this.checkEdgesEventsFrame = null;\n      }\n\n      // Installing new graph\n      this.graph = graph;\n\n      // Binding new handlers\n      this.bindGraphHandlers();\n\n      // Re-rendering now to avoid discrepancies from now to next frame\n      this.refresh();\n    }\n\n    /**\n     * Method returning the mouse captor.\n     *\n     * @return {MouseCaptor}\n     */\n  }, {\n    key: \"getMouseCaptor\",\n    value: function getMouseCaptor() {\n      return this.mouseCaptor;\n    }\n\n    /**\n     * Method returning the touch captor.\n     *\n     * @return {TouchCaptor}\n     */\n  }, {\n    key: \"getTouchCaptor\",\n    value: function getTouchCaptor() {\n      return this.touchCaptor;\n    }\n\n    /**\n     * Method returning the current renderer's dimensions.\n     *\n     * @return {Dimensions}\n     */\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return {\n        width: this.width,\n        height: this.height\n      };\n    }\n\n    /**\n     * Method returning the current graph's dimensions.\n     *\n     * @return {Dimensions}\n     */\n  }, {\n    key: \"getGraphDimensions\",\n    value: function getGraphDimensions() {\n      var extent = this.customBBox || this.nodeExtent;\n      return {\n        width: extent.x[1] - extent.x[0] || 1,\n        height: extent.y[1] - extent.y[0] || 1\n      };\n    }\n\n    /**\n     * Method used to get all the sigma node attributes.\n     * It's usefull for example to get the position of a node\n     * and to get values that are set by the nodeReducer\n     *\n     * @param  {string} key - The node's key.\n     * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found\n     */\n  }, {\n    key: \"getNodeDisplayData\",\n    value: function getNodeDisplayData(key) {\n      var node = this.nodeDataCache[key];\n      return node ? Object.assign({}, node) : undefined;\n    }\n\n    /**\n     * Method used to get all the sigma edge attributes.\n     * It's useful for example to get values that are set by the edgeReducer.\n     *\n     * @param  {string} key - The edge's key.\n     * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found\n     */\n  }, {\n    key: \"getEdgeDisplayData\",\n    value: function getEdgeDisplayData(key) {\n      var edge = this.edgeDataCache[key];\n      return edge ? Object.assign({}, edge) : undefined;\n    }\n\n    /**\n     * Method used to get the set of currently displayed node labels.\n     *\n     * @return {Set<string>} A set of node keys whose label is displayed.\n     */\n  }, {\n    key: \"getNodeDisplayedLabels\",\n    value: function getNodeDisplayedLabels() {\n      return new Set(this.displayedNodeLabels);\n    }\n\n    /**\n     * Method used to get the set of currently displayed edge labels.\n     *\n     * @return {Set<string>} A set of edge keys whose label is displayed.\n     */\n  }, {\n    key: \"getEdgeDisplayedLabels\",\n    value: function getEdgeDisplayedLabels() {\n      return new Set(this.displayedEdgeLabels);\n    }\n\n    /**\n     * Method returning a copy of the settings collection.\n     *\n     * @return {Settings} A copy of the settings collection.\n     */\n  }, {\n    key: \"getSettings\",\n    value: function getSettings() {\n      return _objectSpread2({}, this.settings);\n    }\n\n    /**\n     * Method returning the current value for a given setting key.\n     *\n     * @param  {string} key - The setting key to get.\n     * @return {any} The value attached to this setting key or undefined if not found\n     */\n  }, {\n    key: \"getSetting\",\n    value: function getSetting(key) {\n      return this.settings[key];\n    }\n\n    /**\n     * Method setting the value of a given setting key. Note that this will schedule\n     * a new render next frame.\n     *\n     * @param  {string} key - The setting key to set.\n     * @param  {any}    value - The value to set.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setSetting\",\n    value: function setSetting(key, value) {\n      var oldValues = _objectSpread2({}, this.settings);\n      this.settings[key] = value;\n      validateSettings(this.settings);\n      this.handleSettingsUpdate(oldValues);\n      this.scheduleRefresh();\n      return this;\n    }\n\n    /**\n     * Method updating the value of a given setting key using the provided function.\n     * Note that this will schedule a new render next frame.\n     *\n     * @param  {string}   key     - The setting key to set.\n     * @param  {function} updater - The update function.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"updateSetting\",\n    value: function updateSetting(key, updater) {\n      this.setSetting(key, updater(this.settings[key]));\n      return this;\n    }\n\n    /**\n     * Method used to resize the renderer.\n     *\n     * @param  {boolean} force - If true, then resize is processed even if size is unchanged (optional).\n     * @return {Sigma}\n     */\n  }, {\n    key: \"resize\",\n    value: function resize(force) {\n      var previousWidth = this.width,\n        previousHeight = this.height;\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n      this.pixelRatio = getPixelRatio();\n      if (this.width === 0) {\n        if (this.settings.allowInvalidContainer) this.width = 1;else throw new Error(\"Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n      }\n      if (this.height === 0) {\n        if (this.settings.allowInvalidContainer) this.height = 1;else throw new Error(\"Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n      }\n\n      // If nothing has changed, we can stop right here\n      if (!force && previousWidth === this.width && previousHeight === this.height) return this;\n      this.emit(\"resize\");\n\n      // Sizing dom elements\n      for (var id in this.elements) {\n        var element = this.elements[id];\n        element.style.width = this.width + \"px\";\n        element.style.height = this.height + \"px\";\n      }\n\n      // Sizing canvas contexts\n      for (var _id in this.canvasContexts) {\n        this.elements[_id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n        this.elements[_id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n        if (this.pixelRatio !== 1) this.canvasContexts[_id].scale(this.pixelRatio, this.pixelRatio);\n      }\n\n      // Sizing WebGL contexts\n      for (var _id2 in this.webGLContexts) {\n        this.elements[_id2].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n        this.elements[_id2].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n        var gl = this.webGLContexts[_id2];\n        gl.viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);\n\n        // Clear picking texture if needed\n        if (this.pickingLayers.has(_id2)) {\n          var currentTexture = this.textures[_id2];\n          if (currentTexture) gl.deleteTexture(currentTexture);\n        }\n      }\n      return this;\n    }\n\n    /**\n     * Method used to clear all the canvases.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.emit(\"beforeClear\");\n      this.webGLContexts.nodes.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n      this.webGLContexts.nodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.webGLContexts.edges.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n      this.webGLContexts.edges.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.webGLContexts.hoverNodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);\n      this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);\n      this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);\n      this.emit(\"afterClear\");\n      return this;\n    }\n\n    /**\n     * Method used to refresh, i.e. force the renderer to reprocess graph\n     * data and render, but keep the state.\n     * - if a partialGraph is provided, we only reprocess those nodes & edges.\n     * - if schedule is TRUE, we schedule a render instead of sync render\n     * - if skipIndexation is TRUE, then labelGrid & program indexation are skipped (can be used if you haven't modify x, y, zIndex & size)\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh(opts) {\n      var _this9 = this;\n      var skipIndexation = (opts === null || opts === void 0 ? void 0 : opts.skipIndexation) !== undefined ? opts === null || opts === void 0 ? void 0 : opts.skipIndexation : false;\n      var schedule = (opts === null || opts === void 0 ? void 0 : opts.schedule) !== undefined ? opts.schedule : false;\n      var fullRefresh = !opts || !opts.partialGraph;\n      if (fullRefresh) {\n        // Re-index graph data\n        this.clearEdgeIndices();\n        this.clearNodeIndices();\n        this.graph.forEachNode(function (node) {\n          return _this9.addNode(node);\n        });\n        this.graph.forEachEdge(function (edge) {\n          return _this9.addEdge(edge);\n        });\n      } else {\n        var _opts$partialGraph, _opts$partialGraph2;\n        var nodes = ((_opts$partialGraph = opts.partialGraph) === null || _opts$partialGraph === void 0 ? void 0 : _opts$partialGraph.nodes) || [];\n        for (var i = 0, l = (nodes === null || nodes === void 0 ? void 0 : nodes.length) || 0; i < l; i++) {\n          var node = nodes[i];\n          // Recompute node's data (ie. apply reducer)\n          this.updateNode(node);\n          // Add node to the program if layout is unchanged.\n          // otherwise it will be done in the process function\n          if (skipIndexation) {\n            var programIndex = this.nodeProgramIndex[node];\n            if (programIndex === undefined) throw new Error(\"Sigma: node \\\"\".concat(node, \"\\\" can't be repaint\"));\n            this.addNodeToProgram(node, this.nodeIndices[node], programIndex);\n          }\n        }\n        var edges = (opts === null || opts === void 0 || (_opts$partialGraph2 = opts.partialGraph) === null || _opts$partialGraph2 === void 0 ? void 0 : _opts$partialGraph2.edges) || [];\n        for (var _i4 = 0, _l4 = edges.length; _i4 < _l4; _i4++) {\n          var edge = edges[_i4];\n          // Recompute edge's data (ie. apply reducer)\n          this.updateEdge(edge);\n          // Add edge to the program\n          // otherwise it will be done in the process function\n          if (skipIndexation) {\n            var _programIndex = this.edgeProgramIndex[edge];\n            if (_programIndex === undefined) throw new Error(\"Sigma: edge \\\"\".concat(edge, \"\\\" can't be repaint\"));\n            this.addEdgeToProgram(edge, this.edgeIndices[edge], _programIndex);\n          }\n        }\n      }\n\n      // Do we need to call the process function ?\n      if (fullRefresh || !skipIndexation) this.needToProcess = true;\n      if (schedule) this.scheduleRender();else this.render();\n      return this;\n    }\n\n    /**\n     * Method used to schedule a render at the next available frame.\n     * This method can be safely called on a same frame because it basically\n     * debounces refresh to the next frame.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"scheduleRender\",\n    value: function scheduleRender() {\n      var _this10 = this;\n      if (!this.renderFrame) {\n        this.renderFrame = requestAnimationFrame(function () {\n          _this10.render();\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Method used to schedule a refresh (i.e. fully reprocess graph data and render)\n     * at the next available frame.\n     * This method can be safely called on a same frame because it basically\n     * debounces refresh to the next frame.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"scheduleRefresh\",\n    value: function scheduleRefresh(opts) {\n      return this.refresh(_objectSpread2(_objectSpread2({}, opts), {}, {\n        schedule: true\n      }));\n    }\n\n    /**\n     * Method used to (un)zoom, while preserving the position of a viewport point.\n     * Used for instance to zoom \"on the mouse cursor\".\n     *\n     * @param viewportTarget\n     * @param newRatio\n     * @return {CameraState}\n     */\n  }, {\n    key: \"getViewportZoomedState\",\n    value: function getViewportZoomedState(viewportTarget, newRatio) {\n      var _this$camera$getState = this.camera.getState(),\n        ratio = _this$camera$getState.ratio,\n        angle = _this$camera$getState.angle,\n        x = _this$camera$getState.x,\n        y = _this$camera$getState.y;\n      var _this$settings2 = this.settings,\n        minCameraRatio = _this$settings2.minCameraRatio,\n        maxCameraRatio = _this$settings2.maxCameraRatio;\n      if (typeof maxCameraRatio === \"number\") newRatio = Math.min(newRatio, maxCameraRatio);\n      if (typeof minCameraRatio === \"number\") newRatio = Math.max(newRatio, minCameraRatio);\n      var ratioDiff = newRatio / ratio;\n      var center = {\n        x: this.width / 2,\n        y: this.height / 2\n      };\n      var graphMousePosition = this.viewportToFramedGraph(viewportTarget);\n      var graphCenterPosition = this.viewportToFramedGraph(center);\n      return {\n        angle: angle,\n        x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,\n        y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,\n        ratio: newRatio\n      };\n    }\n\n    /**\n     * Method returning the abstract rectangle containing the graph according\n     * to the camera's state.\n     *\n     * @return {object} - The view's rectangle.\n     */\n  }, {\n    key: \"viewRectangle\",\n    value: function viewRectangle() {\n      var p1 = this.viewportToFramedGraph({\n          x: 0,\n          y: 0\n        }),\n        p2 = this.viewportToFramedGraph({\n          x: this.width,\n          y: 0\n        }),\n        h = this.viewportToFramedGraph({\n          x: 0,\n          y: this.height\n        });\n      return {\n        x1: p1.x,\n        y1: p1.y,\n        x2: p2.x,\n        y2: p2.y,\n        height: p2.y - h.y\n      };\n    }\n\n    /**\n     * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n  }, {\n    key: \"framedGraphToViewport\",\n    value: function framedGraphToViewport(coordinates) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;\n      var matrix = override.matrix ? override.matrix : recomputeMatrix ? matrixFromCamera(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getStagePadding()) : this.matrix;\n      var viewportPos = multiplyVec2(matrix, coordinates);\n      return {\n        x: (1 + viewportPos.x) * this.width / 2,\n        y: (1 - viewportPos.y) * this.height / 2\n      };\n    }\n\n    /**\n     * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n  }, {\n    key: \"viewportToFramedGraph\",\n    value: function viewportToFramedGraph(coordinates) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;\n      var invMatrix = override.matrix ? override.matrix : recomputeMatrix ? matrixFromCamera(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getStagePadding(), true) : this.invMatrix;\n      var res = multiplyVec2(invMatrix, {\n        x: coordinates.x / this.width * 2 - 1,\n        y: 1 - coordinates.y / this.height * 2\n      });\n      if (isNaN(res.x)) res.x = 0;\n      if (isNaN(res.y)) res.y = 0;\n      return res;\n    }\n\n    /**\n     * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the\n     * stage) to the graph system (the reference system of data as they are in the given graph instance).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  viewportPoint\n     * @param {CoordinateConversionOverride} override\n     */\n  }, {\n    key: \"viewportToGraph\",\n    value: function viewportToGraph(viewportPoint) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));\n    }\n\n    /**\n     * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in\n     * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  graphPoint\n     * @param {CoordinateConversionOverride} override\n     */\n  }, {\n    key: \"graphToViewport\",\n    value: function graphToViewport(graphPoint) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);\n    }\n\n    /**\n     * Method returning the distance multiplier between the graph system and the\n     * viewport system.\n     */\n  }, {\n    key: \"getGraphToViewportRatio\",\n    value: function getGraphToViewportRatio() {\n      var graphP1 = {\n        x: 0,\n        y: 0\n      };\n      var graphP2 = {\n        x: 1,\n        y: 1\n      };\n      var graphD = Math.sqrt(Math.pow(graphP1.x - graphP2.x, 2) + Math.pow(graphP1.y - graphP2.y, 2));\n      var viewportP1 = this.graphToViewport(graphP1);\n      var viewportP2 = this.graphToViewport(graphP2);\n      var viewportD = Math.sqrt(Math.pow(viewportP1.x - viewportP2.x, 2) + Math.pow(viewportP1.y - viewportP2.y, 2));\n      return viewportD / graphD;\n    }\n\n    /**\n     * Method returning the graph's bounding box.\n     *\n     * @return {{ x: Extent, y: Extent }}\n     */\n  }, {\n    key: \"getBBox\",\n    value: function getBBox() {\n      return this.nodeExtent;\n    }\n\n    /**\n     * Method returning the graph's custom bounding box, if any.\n     *\n     * @return {{ x: Extent, y: Extent } | null}\n     */\n  }, {\n    key: \"getCustomBBox\",\n    value: function getCustomBBox() {\n      return this.customBBox;\n    }\n\n    /**\n     * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setCustomBBox\",\n    value: function setCustomBBox(customBBox) {\n      this.customBBox = customBBox;\n      this.scheduleRender();\n      return this;\n    }\n\n    /**\n     * Method used to shut the container & release event listeners.\n     *\n     * @return {undefined}\n     */\n  }, {\n    key: \"kill\",\n    value: function kill() {\n      // Emitting \"kill\" events so that plugins and such can cleanup\n      this.emit(\"kill\");\n\n      // Releasing events\n      this.removeAllListeners();\n\n      // Releasing camera handlers\n      this.unbindCameraHandlers();\n\n      // Releasing DOM events & captors\n      window.removeEventListener(\"resize\", this.activeListeners.handleResize);\n      this.mouseCaptor.kill();\n      this.touchCaptor.kill();\n\n      // Releasing graph handlers\n      this.unbindGraphHandlers();\n\n      // Releasing cache & state\n      this.clearIndices();\n      this.clearState();\n      this.nodeDataCache = {};\n      this.edgeDataCache = {};\n      this.highlightedNodes.clear();\n\n      // Clearing frames\n      if (this.renderFrame) {\n        cancelAnimationFrame(this.renderFrame);\n        this.renderFrame = null;\n      }\n      if (this.renderHighlightedNodesFrame) {\n        cancelAnimationFrame(this.renderHighlightedNodesFrame);\n        this.renderHighlightedNodesFrame = null;\n      }\n\n      // Destroying canvases\n      var container = this.container;\n      while (container.firstChild) container.removeChild(container.firstChild);\n\n      // Destroying remaining collections\n      this.canvasContexts = {};\n      this.webGLContexts = {};\n      this.elements = {};\n\n      // Kill programs:\n      for (var type in this.nodePrograms) {\n        this.nodePrograms[type].kill();\n      }\n      for (var _type8 in this.nodeHoverPrograms) {\n        this.nodeHoverPrograms[_type8].kill();\n      }\n      for (var _type9 in this.edgePrograms) {\n        this.edgePrograms[_type9].kill();\n      }\n      this.nodePrograms = {};\n      this.nodeHoverPrograms = {};\n      this.edgePrograms = {};\n\n      // Kill all canvas/WebGL contexts\n      for (var id in this.elements) {\n        this.killLayer(id);\n      }\n    }\n\n    /**\n     * Method used to scale the given size according to the camera's ratio, i.e.\n     * zooming state.\n     *\n     * @param  {number?} size -        The size to scale (node size, edge thickness etc.).\n     * @param  {number?} cameraRatio - A camera ratio (defaults to the actual camera ratio).\n     * @return {number}              - The scaled size.\n     */\n  }, {\n    key: \"scaleSize\",\n    value: function scaleSize() {\n      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var cameraRatio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.camera.ratio;\n      return size / this.settings.zoomToSizeRatioFunction(cameraRatio) * (this.getSetting(\"itemSizesReference\") === \"positions\" ? cameraRatio * this.graphToViewportRatio : 1);\n    }\n\n    /**\n     * Method that returns the collection of all used canvases.\n     * At the moment, the instantiated canvases are the following, and in the\n     * following order in the DOM:\n     * - `edges`\n     * - `nodes`\n     * - `edgeLabels`\n     * - `labels`\n     * - `hovers`\n     * - `hoverNodes`\n     * - `mouse`\n     *\n     * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.\n     */\n  }, {\n    key: \"getCanvases\",\n    value: function getCanvases() {\n      return _objectSpread2({}, this.elements);\n    }\n  }]);\n  return Sigma;\n}(TypedEventEmitter);\n\n/**\n * Sigma.js Library Endpoint\n * =========================\n *\n * The library endpoint.\n * @module\n */\nvar Sigma = Sigma$1;\n\nexport { Camera, MouseCaptor, Sigma$1 as Sigma, TouchCaptor, Sigma as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}