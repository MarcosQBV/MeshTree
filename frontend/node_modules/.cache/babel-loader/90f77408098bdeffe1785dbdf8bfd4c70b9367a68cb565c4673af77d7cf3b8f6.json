{"ast":null,"code":"var _jsxFileName = \"D:\\\\code\\\\MeshTree\\\\frontend\\\\src\\\\GraphWrapper.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from 'react';\nimport { SigmaContainer, useSigma } from '@react-sigma/core';\nimport Graph from 'graphology';\n\n// CSS for fade-in effect remains the same\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst fadeInStyle = `\n  .fade-in {\n    opacity: 0;\n    animation: fadeIn 1s forwards;\n  }\n\n  @keyframes fadeIn {\n    to {\n      opacity: 1;\n    }\n  }\n`;\n\n// Inject the CSS into the document\nconst styleSheet = document.createElement(\"style\");\nstyleSheet.type = \"text/css\";\nstyleSheet.innerText = fadeInStyle;\ndocument.head.appendChild(styleSheet);\nasync function fetchDataForKey(key) {\n  const baseUrl = 'http://localhost:5000';\n  const url = `${baseUrl}/get/${key}`;\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP error! Status: ${response.status}`);\n    }\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Error fetching data:', error);\n    throw error;\n  }\n}\nfunction defineEdges(data, centralNodeId) {\n  const edges = [];\n  data.children.forEach(child => {\n    edges.push({\n      source: centralNodeId,\n      target: child.id\n    });\n  });\n  data.parents.forEach(parent => {\n    edges.push({\n      source: parent.id,\n      target: centralNodeId\n    });\n  });\n  return edges;\n}\nconst GraphComponent = () => {\n  _s();\n  const sigma = useSigma();\n  const containerRef = useRef(null);\n  const graphRef = useRef(new Graph());\n  const [centralNode, setCentralNode] = useState({\n    id: 'Root',\n    label: 'Root'\n  });\n  const [parentNodes, setParentNodes] = useState([]);\n  const [childNodes, setChildNodes] = useState([]);\n  const [edges, setEdges] = useState([]);\n  const [nodeLevel, setNodeLevel] = useState([]);\n  const [centerX, setCenterX] = useState(0);\n  const [centerY, setCenterY] = useState(0);\n  const [collapsedNodes, setCollapsedNodes] = useState(new Set());\n  // Add a new state to track collapsed node data\n  const [collapsedNodeData, setCollapsedNodeData] = useState(new Map());\n  function getNodeLabelById(nodeId, nodes) {\n    const node = nodes.find(node => node.id === nodeId);\n    return node ? node.label : null;\n  }\n  const handleNodeClick = async nodeId => {\n    const newLabel = getNodeLabelById(nodeId, [...parentNodes, ...childNodes]);\n    console.log(`Node clicked: ${nodeId}, Label: ${newLabel}`);\n    if (newLabel) {\n      // Check if the node was previously collapsed\n      if (collapsedNodes.has(nodeId)) {\n        await expandNode(nodeId);\n      }\n      setCentralNode({\n        id: nodeId,\n        label: newLabel\n      });\n      const nodeAttributes = graphRef.current.getNodeAttributes(nodeId);\n      setCenterX(nodeAttributes.x);\n      setCenterY(nodeAttributes.y);\n    } else {\n      console.warn(`Node label not found for ID: ${nodeId}`);\n    }\n  };\n\n  // New function to handle node expansion\n  const expandNode = async nodeId => {\n    const graph = graphRef.current;\n    const storedData = collapsedNodeData.get(nodeId);\n    if (storedData) {\n      // Restore the collapsed children and their edges\n      for (const child of storedData.children) {\n        if (!graph.hasNode(child.id)) {\n          const angle = Math.random() * 2 * Math.PI; // Random angle for initial placement\n          const radius = 100; // Consistent with your existing radius\n          const x = centerX + radius * Math.cos(angle);\n          const y = centerY + radius * Math.sin(angle);\n          graph.addNode(child.id, {\n            label: child.label,\n            size: 20,\n            color: 'black',\n            className: 'fade-in',\n            x: x,\n            y: y\n          });\n        }\n      }\n\n      // Restore edges\n      for (const edge of storedData.edges) {\n        if (!graph.hasEdge(edge.source, edge.target)) {\n          try {\n            graph.addEdge(edge.source, edge.target);\n          } catch (error) {\n            console.warn(`Failed to add edge from ${edge.source} to ${edge.target}:`, error);\n          }\n        }\n      }\n\n      // Remove the node from collapsed tracking\n      setCollapsedNodes(prev => {\n        const newSet = new Set(prev);\n        newSet.delete(nodeId);\n        return newSet;\n      });\n      setCollapsedNodeData(prev => {\n        const newMap = new Map(prev);\n        newMap.delete(nodeId);\n        return newMap;\n      });\n      sigma.refresh();\n    }\n  };\n  const handleNodeRightClick = nodeId => {\n    collapseNodeAndDescendants(nodeId);\n  };\n  const collapseNodeAndDescendants = nodeId => {\n    const graph = graphRef.current;\n    const nodesToRemove = new Set();\n    const edgesToRemove = new Set();\n    const collapsedChildren = [];\n    const collapsedEdges = [];\n\n    // Collect direct children of the node and their data\n    graph.forEachOutboundNeighbor(nodeId, neighbor => {\n      nodesToRemove.add(neighbor);\n      collapsedChildren.push({\n        id: neighbor,\n        label: graph.getNodeAttributes(neighbor).label\n      });\n    });\n\n    // Collect all edges connected to these nodes\n    nodesToRemove.forEach(node => {\n      graph.forEachEdge(node, (edgeId, attributes, source, target) => {\n        edgesToRemove.add(edgeId);\n        collapsedEdges.push({\n          source,\n          target\n        });\n      });\n    });\n\n    // Store the collapsed node data before removing\n    setCollapsedNodeData(prev => {\n      const newMap = new Map(prev);\n      newMap.set(nodeId, {\n        children: collapsedChildren,\n        edges: collapsedEdges\n      });\n      return newMap;\n    });\n\n    // Remove edges and nodes from the graph\n    edgesToRemove.forEach(edgeId => {\n      if (graph.hasEdge(edgeId)) {\n        graph.dropEdge(edgeId);\n      }\n    });\n    nodesToRemove.forEach(node => {\n      if (graph.hasNode(node)) {\n        graph.dropNode(node);\n      }\n    });\n\n    // Update collapsed nodes tracking\n    setCollapsedNodes(prev => {\n      const newSet = new Set(prev);\n      newSet.add(nodeId);\n      return newSet;\n    });\n    sigma.refresh();\n  };\n\n  // Rest of the useEffect hooks remain the same...\n  // [Previous useEffect hooks for fetching data and updating graph visualization]\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 209,\n    columnNumber: 10\n  }, this);\n};\n_s(GraphComponent, \"qUVwvo3qBf+mvmYmHTf5peJmfGI=\", false, function () {\n  return [useSigma];\n});\n_c = GraphComponent;\nconst GraphWrapper = () => /*#__PURE__*/_jsxDEV(SigmaContainer, {\n  children: /*#__PURE__*/_jsxDEV(GraphComponent, {}, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 214,\n    columnNumber: 5\n  }, this)\n}, void 0, false, {\n  fileName: _jsxFileName,\n  lineNumber: 213,\n  columnNumber: 3\n}, this);\n_c2 = GraphWrapper;\nexport default GraphWrapper;\nvar _c, _c2;\n$RefreshReg$(_c, \"GraphComponent\");\n$RefreshReg$(_c2, \"GraphWrapper\");","map":{"version":3,"names":["React","useEffect","useRef","useState","SigmaContainer","useSigma","Graph","jsxDEV","_jsxDEV","fadeInStyle","styleSheet","document","createElement","type","innerText","head","appendChild","fetchDataForKey","key","baseUrl","url","response","fetch","ok","Error","status","data","json","error","console","defineEdges","centralNodeId","edges","children","forEach","child","push","source","target","id","parents","parent","GraphComponent","_s","sigma","containerRef","graphRef","centralNode","setCentralNode","label","parentNodes","setParentNodes","childNodes","setChildNodes","setEdges","nodeLevel","setNodeLevel","centerX","setCenterX","centerY","setCenterY","collapsedNodes","setCollapsedNodes","Set","collapsedNodeData","setCollapsedNodeData","Map","getNodeLabelById","nodeId","nodes","node","find","handleNodeClick","newLabel","log","has","expandNode","nodeAttributes","current","getNodeAttributes","x","y","warn","graph","storedData","get","hasNode","angle","Math","random","PI","radius","cos","sin","addNode","size","color","className","edge","hasEdge","addEdge","prev","newSet","delete","newMap","refresh","handleNodeRightClick","collapseNodeAndDescendants","nodesToRemove","edgesToRemove","collapsedChildren","collapsedEdges","forEachOutboundNeighbor","neighbor","add","forEachEdge","edgeId","attributes","set","dropEdge","dropNode","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","GraphWrapper","_c2","$RefreshReg$"],"sources":["D:/code/MeshTree/frontend/src/GraphWrapper.jsx"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\r\nimport { SigmaContainer, useSigma } from '@react-sigma/core';\r\nimport Graph from 'graphology';\r\n\r\n// CSS for fade-in effect remains the same\r\nconst fadeInStyle = `\r\n  .fade-in {\r\n    opacity: 0;\r\n    animation: fadeIn 1s forwards;\r\n  }\r\n\r\n  @keyframes fadeIn {\r\n    to {\r\n      opacity: 1;\r\n    }\r\n  }\r\n`;\r\n\r\n// Inject the CSS into the document\r\nconst styleSheet = document.createElement(\"style\");\r\nstyleSheet.type = \"text/css\";\r\nstyleSheet.innerText = fadeInStyle;\r\ndocument.head.appendChild(styleSheet);\r\n\r\nasync function fetchDataForKey(key) {\r\n  const baseUrl = 'http://localhost:5000';\r\n  const url = `${baseUrl}/get/${key}`;\r\n\r\n  try {\r\n    const response = await fetch(url);\r\n    if (!response.ok) {\r\n      throw new Error(`HTTP error! Status: ${response.status}`);\r\n    }\r\n    const data = await response.json();\r\n    return data;\r\n  } catch (error) {\r\n    console.error('Error fetching data:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\nfunction defineEdges(data, centralNodeId) {\r\n  const edges = [];\r\n  data.children.forEach((child) => {\r\n    edges.push({ source: centralNodeId, target: child.id });\r\n  });\r\n  data.parents.forEach((parent) => {\r\n    edges.push({ source: parent.id, target: centralNodeId });\r\n  });\r\n  return edges;\r\n}\r\n\r\nconst GraphComponent = () => {\r\n  const sigma = useSigma();\r\n  const containerRef = useRef(null);\r\n  const graphRef = useRef(new Graph());\r\n  const [centralNode, setCentralNode] = useState({ id: 'Root', label: 'Root' });\r\n  const [parentNodes, setParentNodes] = useState([]);\r\n  const [childNodes, setChildNodes] = useState([]);\r\n  const [edges, setEdges] = useState([]);\r\n  const [nodeLevel, setNodeLevel] = useState([]);\r\n  const [centerX, setCenterX] = useState(0);\r\n  const [centerY, setCenterY] = useState(0);\r\n  const [collapsedNodes, setCollapsedNodes] = useState(new Set());\r\n  // Add a new state to track collapsed node data\r\n  const [collapsedNodeData, setCollapsedNodeData] = useState(new Map());\r\n\r\n  function getNodeLabelById(nodeId, nodes) {\r\n    const node = nodes.find((node) => node.id === nodeId);\r\n    return node ? node.label : null;\r\n  }\r\n\r\n  const handleNodeClick = async (nodeId) => {\r\n    const newLabel = getNodeLabelById(nodeId, [...parentNodes, ...childNodes]);\r\n    console.log(`Node clicked: ${nodeId}, Label: ${newLabel}`);\r\n\r\n    if (newLabel) {\r\n      // Check if the node was previously collapsed\r\n      if (collapsedNodes.has(nodeId)) {\r\n        await expandNode(nodeId);\r\n      }\r\n\r\n      setCentralNode({ id: nodeId, label: newLabel });\r\n      const nodeAttributes = graphRef.current.getNodeAttributes(nodeId);\r\n      setCenterX(nodeAttributes.x);\r\n      setCenterY(nodeAttributes.y);\r\n    } else {\r\n      console.warn(`Node label not found for ID: ${nodeId}`);\r\n    }\r\n  };\r\n\r\n  // New function to handle node expansion\r\n  const expandNode = async (nodeId) => {\r\n    const graph = graphRef.current;\r\n    const storedData = collapsedNodeData.get(nodeId);\r\n    \r\n    if (storedData) {\r\n      // Restore the collapsed children and their edges\r\n      for (const child of storedData.children) {\r\n        if (!graph.hasNode(child.id)) {\r\n          const angle = Math.random() * 2 * Math.PI; // Random angle for initial placement\r\n          const radius = 100; // Consistent with your existing radius\r\n          const x = centerX + radius * Math.cos(angle);\r\n          const y = centerY + radius * Math.sin(angle);\r\n          \r\n          graph.addNode(child.id, {\r\n            label: child.label,\r\n            size: 20,\r\n            color: 'black',\r\n            className: 'fade-in',\r\n            x: x,\r\n            y: y\r\n          });\r\n        }\r\n      }\r\n\r\n      // Restore edges\r\n      for (const edge of storedData.edges) {\r\n        if (!graph.hasEdge(edge.source, edge.target)) {\r\n          try {\r\n            graph.addEdge(edge.source, edge.target);\r\n          } catch (error) {\r\n            console.warn(`Failed to add edge from ${edge.source} to ${edge.target}:`, error);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Remove the node from collapsed tracking\r\n      setCollapsedNodes(prev => {\r\n        const newSet = new Set(prev);\r\n        newSet.delete(nodeId);\r\n        return newSet;\r\n      });\r\n\r\n      setCollapsedNodeData(prev => {\r\n        const newMap = new Map(prev);\r\n        newMap.delete(nodeId);\r\n        return newMap;\r\n      });\r\n\r\n      sigma.refresh();\r\n    }\r\n  };\r\n\r\n  const handleNodeRightClick = (nodeId) => {\r\n    collapseNodeAndDescendants(nodeId);\r\n  };\r\n\r\n  const collapseNodeAndDescendants = (nodeId) => {\r\n    const graph = graphRef.current;\r\n    const nodesToRemove = new Set();\r\n    const edgesToRemove = new Set();\r\n    const collapsedChildren = [];\r\n    const collapsedEdges = [];\r\n\r\n    // Collect direct children of the node and their data\r\n    graph.forEachOutboundNeighbor(nodeId, (neighbor) => {\r\n      nodesToRemove.add(neighbor);\r\n      collapsedChildren.push({\r\n        id: neighbor,\r\n        label: graph.getNodeAttributes(neighbor).label\r\n      });\r\n    });\r\n\r\n    // Collect all edges connected to these nodes\r\n    nodesToRemove.forEach((node) => {\r\n      graph.forEachEdge(node, (edgeId, attributes, source, target) => {\r\n        edgesToRemove.add(edgeId);\r\n        collapsedEdges.push({ source, target });\r\n      });\r\n    });\r\n\r\n    // Store the collapsed node data before removing\r\n    setCollapsedNodeData(prev => {\r\n      const newMap = new Map(prev);\r\n      newMap.set(nodeId, {\r\n        children: collapsedChildren,\r\n        edges: collapsedEdges\r\n      });\r\n      return newMap;\r\n    });\r\n\r\n    // Remove edges and nodes from the graph\r\n    edgesToRemove.forEach((edgeId) => {\r\n      if (graph.hasEdge(edgeId)) {\r\n        graph.dropEdge(edgeId);\r\n      }\r\n    });\r\n\r\n    nodesToRemove.forEach((node) => {\r\n      if (graph.hasNode(node)) {\r\n        graph.dropNode(node);\r\n      }\r\n    });\r\n\r\n    // Update collapsed nodes tracking\r\n    setCollapsedNodes(prev => {\r\n      const newSet = new Set(prev);\r\n      newSet.add(nodeId);\r\n      return newSet;\r\n    });\r\n\r\n    sigma.refresh();\r\n  };\r\n\r\n  // Rest of the useEffect hooks remain the same...\r\n  // [Previous useEffect hooks for fetching data and updating graph visualization]\r\n\r\n  return <div ref={containerRef} />;\r\n};\r\n\r\nconst GraphWrapper = () => (\r\n  <SigmaContainer>\r\n    <GraphComponent />\r\n  </SigmaContainer>\r\n);\r\n\r\nexport default GraphWrapper;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}